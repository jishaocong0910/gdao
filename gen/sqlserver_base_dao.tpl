// Code generated by https://github.com/jishaocong0910/gdao. YOU CAN EDIT FOR MORE.

package {{.Package}}

import (
	"context"
	"strconv"
	"strings"

	"github.com/jishaocong0910/gdao"
)

func getConditionBuilder[T any](b *gdao.Builder[T]) conditionBuilder {
	return conditionBuilder{
		write: func(str string, args ...any) {
			b.Write(str, args...)
		},
	}
}

func parenthesizeGroup(c condition) {
	if cg, ok := c.(*conditionGroup); ok {
		if len(cg.cs) > 1 && cg.or {
			cg.parenthesized = true
		}
	}
}

type conditionBuilder struct {
	write func(str string, args ...any)
	pp    func(prefix string) string
}

type condition interface {
	write(b conditionBuilder)
}

type baseCondition struct {
	not           bool
	parenthesized bool
}

func (bc baseCondition) doWrite(b conditionBuilder, write func()) {
	if bc.not {
		b.write("NOT ")
	}
	if bc.parenthesized {
		b.write("(")
	}
	write()
	if bc.parenthesized {
		b.write(")")
	}
}

type conditionGroup struct {
	baseCondition
	or bool
	cs []condition
}

func (cg *conditionGroup) write(b conditionBuilder) {
	cg.doWrite(b, func() {
		for i, cond := range cg.cs {
			if i != 0 {
				if cg.or {
					b.write(" OR ")
				} else {
					b.write(" AND ")
				}
			}
			cond.write(b)
		}
	})
}

func (cg *conditionGroup) addCondition(other condition) *conditionGroup {
	if len(cg.cs) > 0 {
		if cg.not == true {
			cg.parenthesized = true
		}
		parenthesizeGroup(other)
		if len(cg.cs) == 1 {
			parenthesizeGroup(cg.cs[0])
		}
	}
	cg.cs = append(cg.cs, other)
	return cg
}

func (cg *conditionGroup) ToStrArgs() (string, []any) {
	var str strings.Builder
	var args []any
	cb := conditionBuilder{
		write: func(s string, a ...any) {
			str.WriteString(s)
			args = append(args, a...)
		},
	}
	cg.write(cb)
	return str.String(), args
}

func (cg *conditionGroup) Group(other *conditionGroup) *conditionGroup {
	if other == nil || len(other.cs) == 0 {
		return cg
	}
	return cg.addCondition(other)
}

func (cg *conditionGroup) Plain(sql string, args ...any) *conditionGroup {
	return cg.addCondition(&conditionPlain{sql: sql, args: args})
}

func (cg *conditionGroup) Eq(column string, arg any) *conditionGroup {
	return cg.addCondition(&conditionBinOp{column: column, op: "=", arg: arg})
}

func (cg *conditionGroup) NotEq(column string, arg any) *conditionGroup {
	return cg.addCondition(&conditionBinOp{column: column, op: "<>", arg: arg})
}

func (cg *conditionGroup) Gt(column string, arg any) *conditionGroup {
	return cg.addCondition(&conditionBinOp{column: column, op: ">", arg: arg})
}

func (cg *conditionGroup) Lt(column string, arg any) *conditionGroup {
	return cg.addCondition(&conditionBinOp{column: column, op: "<", arg: arg})
}

func (cg *conditionGroup) GtEq(column string, arg any) *conditionGroup {
	return cg.addCondition(&conditionBinOp{column: column, op: ">=", arg: arg})
}

func (cg *conditionGroup) LtEq(column string, arg any) *conditionGroup {
	return cg.addCondition(&conditionBinOp{column: column, op: "<=", arg: arg})
}

func (cg *conditionGroup) Like(column string, arg string) *conditionGroup {
	return cg.addCondition(&conditionBinOp{column: column, op: " LIKE ", arg: "%" + arg + "%"})
}

func (cg *conditionGroup) LikeLeft(column string, arg string) *conditionGroup {
	return cg.addCondition(&conditionBinOp{column: column, op: " LIKE ", arg: arg + "%"})
}

func (cg *conditionGroup) LikeRight(column string, arg string) *conditionGroup {
	return cg.addCondition(&conditionBinOp{column: column, op: " LIKE ", arg: "%" + arg})
}

func (cg *conditionGroup) In(column string, args ...any) *conditionGroup {
	return cg.addCondition(&conditionIn{column: column, args: args})
}

func (cg *conditionGroup) Between(column string, min, max any) *conditionGroup {
	return cg.addCondition(&conditionBetween{column: column, min: min, max: max})
}

func (cg *conditionGroup) IsNull(column string) *conditionGroup {
	return cg.addCondition(&conditionIsNull{column: column})
}

func (cg *conditionGroup) IsNotNull(column string) *conditionGroup {
	return cg.addCondition(&conditionIsNull{column: column, notNull: true})
}

type conditionPlain struct {
	baseCondition
	sql  string
	args []any
}

func (c *conditionPlain) write(b conditionBuilder) {
	c.doWrite(b, func() {
		b.write(c.sql, c.args...)
	})
}

type conditionBinOp struct {
	baseCondition
	column string
	op     string
	arg    any
}

func (c conditionBinOp) write(b conditionBuilder) {
	c.doWrite(b, func() {
		b.write(c.column)
		b.write(c.op)
		b.write(b.pp(":"), c.arg)
	})
}

type conditionIn struct {
	baseCondition
	column string
	args   []any
}

func (c conditionIn) write(b conditionBuilder) {
	c.doWrite(b, func() {
		b.write(c.column)
		b.write(" IN(")
		for i := 0; i < len(c.args); i++ {
			if i != 0 {
				b.write(",")
			}
			b.write(b.pp(":"))
		}
		b.write(")", c.args...)
	})
}

type conditionBetween struct {
	baseCondition
	column   string
	min, max any
}

func (c conditionBetween) write(b conditionBuilder) {
	c.doWrite(b, func() {
		b.write(c.column)
		b.write(" BETWEEN ")
		b.write(b.pp(":"))
		b.write(" AND ")
		b.write(b.pp(":"), c.min, c.max)
	})
}

type conditionIsNull struct {
	baseCondition
	notNull bool
	column  string
}

func (c conditionIsNull) write(b conditionBuilder) {
	c.doWrite(b, func() {
		b.write(c.column)
		b.write(" IS")
		if c.notNull {
			b.write(" NOT")
		}
		b.write(" NULL")
	})
}

type ListReq struct {
	Ctx context.Context
	// specify the columns which in the select column list, default is all columns.
	SelectColumns []string
	// conditions of the WHERE clause，create by function And, Or, NotAnd and NotOr.
	Condition *conditionGroup
	// ORDER BY clause，create by function OrderBy.
	OrderBy *orderBy
	// paging query，create by function Page.
	Pagination *pagination
	// FOR UPDATE clause
	ForUpdate bool
}

type GetReq struct {
	Ctx context.Context
	// specify the columns which in the select column list, default is all columns.
	SelectColumns []string
	// conditions of the WHERE clause，create by function And, Or, NotAnd and NotOr.
	Condition *conditionGroup
	// FOR UPDATE clause
	ForUpdate bool
}

type InsertReq[T any] struct {
	Ctx context.Context
	// the non-nil fields will be saved, and the auto generated keys will be set in it.
	Entity *T
	// if true, all fields will be saved, otherwise, save non-nil fields.
	InsertAll bool
	// specify the columns which save a null value, it will not work when UpdateAll is true
	SetNullColumns []string
}

type InsertBatchReq[T any] struct {
	Ctx context.Context
	// each element corresponds to a record to be saved, and the auto generated keys will be set in them.
	Entities []*T
	// specify the columns in the insert column list, default is all columns.
	InsertColumns []string
	// specify the columns which be ignored from the insert column list.
	IgnoredColumns []string
}

type UpdateReq[T any] struct {
	Ctx context.Context
	// uses to update values or as the WHERE clause conditions.
	Entity *T
	// if true, all fields will be updated, otherwise, update non-nil fields.
	UpdateAll bool
	// specify the columns update to null, it will not work when UpdateAll is true
	SetNullColumns []string
	// specify the non-nil fields in the entity used as conditions.
	WhereColumns []string
	// conditions of the WHERE clause，create by function And, Or, NotAnd and NotOr..
	Condition *conditionGroup
}

type UpdateBatchReq[T any] struct {
	Ctx context.Context
	// each element corresponds to a record to be updated.
	Entities []*T
	// specify the columns which in the set list, default is all columns.
	SetColumns []string
	// specify the columns which be ignored from set list.
	IgnoredColumns []string
	// specify the column which used as a condition.
	WhereColumn string
}

type DeleteReq struct {
	Ctx context.Context
	// conditions of the WHERE clause，create by function And, Or, NotAnd and NotOr.
	Condition *conditionGroup
}

type orderBy struct {
	items []orderByItem
}

func (o *orderBy) Asc(column string) *orderBy {
	o.items = append(o.items, orderByItem{column: column, sequence: asc})
	return o
}

func (o *orderBy) Desc(column string) *orderBy {
	o.items = append(o.items, orderByItem{column: column, sequence: desc})
	return o
}

type orderBySequence string

const (
	asc  orderBySequence = "ASC"
	desc                 = "DESC"
)

type orderByItem struct {
	column   string
	sequence orderBySequence
}

type pagination struct {
	page, pageSize int
}

type baseDao[T any] struct {
	*gdao.Dao[T]
	table string
}

// List queries records of the conditions.
func (d baseDao[T]) List(req ListReq) ([]*T, error) {
	_, list, err := d.Query(gdao.QueryReq[T]{Ctx: req.Ctx, BuildSql: func(b *gdao.Builder[T]) {
		if req.Condition == nil {
			b.SetOk(false)
			return
		}
		b.Write("SELECT ").WriteColumns(req.SelectColumns...).Write(" FROM ").Write(d.table).Write(" WHERE ")
		cb := getConditionBuilder(b)
		req.Condition.write(cb)
		if req.OrderBy != nil {
			b.Repeat(len(req.OrderBy.items), b.SepFix(" ORDER BY ", ",", "", false), nil, func(n, i int) {
				item := req.OrderBy.items[i]
				b.Write(item.column).Write(" ")
				b.Write(string(item.sequence))
			})
			if req.Pagination != nil {
				page := req.Pagination.page
				pageSize := req.Pagination.pageSize
				if page > 0 && pageSize > 0 {
					b.Write(" OFFSET ")
					b.Write(strconv.FormatInt(int64((page-1)*pageSize), 10))
					b.Write(" FETCH NEXT ")
					b.Write(strconv.FormatInt(int64(pageSize), 10))
					b.Write(" ROWS ONLY")
				}
			}
		}
		if req.ForUpdate {
			b.Write(" FOR UPDATE")
		}
	}})
	return list, err
}

// Get queries a record of the conditions.
func (d baseDao[T]) Get(req GetReq) (*T, error) {
	first, _, err := d.Query(gdao.QueryReq[T]{Ctx: req.Ctx, BuildSql: func(b *gdao.Builder[T]) {
		if req.Condition == nil {
			b.SetOk(false)
			return
		}
		b.Write("SELECT TOP 1 ").WriteColumns(req.SelectColumns...).Write(" FROM ").Write(d.table).Write(" WHERE ")
		cb := getConditionBuilder(b)
		req.Condition.write(cb)
		if req.ForUpdate {
			b.Write(" FOR UPDATE")
		}
	}})
	return first, err
}

// Insert saves a record and return the auto generated keys.
func (d baseDao[T]) Insert(req InsertReq[T]) error {
	_, _, err := d.Query(gdao.QueryReq[T]{Ctx: req.Ctx, RowAs: gdao.ROW_AS_LAST_ID, Entities: []*T{req.Entity},
		BuildSql: func(b *gdao.Builder[T]) {
			var entityFieldNum, setNullColumnNum int
			b.Write("INSERT INTO ").Write(d.table).Write("(")
			var cvs []gdao.ColumnValue
			if req.InsertAll {
				cvs = b.ColumnValues(false)
			} else {
				cvs = b.ColumnValues(true)
			}
			b.SetOk(false)
			b.EachColumnValues(cvs, b.Sep(","), func(column string, value any) {
				b.SetOk(true)
				entityFieldNum++
				b.Write(column, value)
			})
			if !req.InsertAll {
				b.EachColumnName(req.SetNullColumns, nil, func(_, _ int, column string) {
					if b.Ok() {
						b.Write(",")
					}
					b.SetOk(true)
					setNullColumnNum++
					b.Write(column)
				})
			}
			b.Write(")")
			b.Repeat(entityFieldNum+setNullColumnNum, b.SepFix(" VALUES(", ",", ")", false), nil, func(n, i int) {
				if i < entityFieldNum {
					b.Write(b.Pp(":"))
				} else {
					b.Write("NULL")
				}
			})
			if len(b.AutoColumns()) == 1 {
				b.Write("; SELECT ID=convert(bigint, SCOPE_IDENTITY())")
			}
		}})
	return err
}

// InsertBatch saves records and return the auto generated keys.
func (d baseDao[T]) InsertBatch(req InsertBatchReq[T]) error {
	_, _, err := d.Query(gdao.QueryReq[T]{Ctx: req.Ctx, RowAs: gdao.ROW_AS_LAST_ID, Entities: req.Entities,
		BuildSql: func(b *gdao.Builder[T]) {
			var allIgnoredColumns []string
			allIgnoredColumns = append(allIgnoredColumns, req.IgnoredColumns...)
			allIgnoredColumns = append(allIgnoredColumns, b.AutoColumns()...)
			b.Write("INSERT INTO ").Write(d.table)
			b.EachColumnName(b.Columns(req.InsertColumns...), b.SepFix("(", ",", ")", false), func(_, _ int, column string) {
				b.Write(column)
			}, allIgnoredColumns...)
			b.Write(" VALUES")
			b.SetOk(false)
			b.EachEntity(b.Sep(","), func(_, _ int, entity *T) {
				b.SetOk(true)
				cvs := b.ColumnValuesAt(entity, false, allIgnoredColumns...)
				b.EachColumnValues(cvs, b.SepFix("(", ",", ")", false), func(column string, value any) {
					b.Write(b.Pp(":")).Arg(value)
				})
			})
			if len(b.AutoColumns()) == 1 {
				b.Write("; SELECT ID=convert(bigint, SCOPE_IDENTITY())")
			}
		}})
	return err
}

// Update modifies a record.
func (d baseDao[T]) Update(req UpdateReq[T]) (int64, error) {
	return d.Exec(gdao.ExecReq[T]{Ctx: req.Ctx, Entities: []*T{req.Entity},
		BuildSql: func(b *gdao.Builder[T]) {
			b.Write("UPDATE ").Write(d.table).Write(" SET ")
			var setCvs []gdao.ColumnValue
			if req.UpdateAll {
				setCvs = b.ColumnValues(false, req.WhereColumns...)
			} else {
				var allIgnoredColumns []string
				allIgnoredColumns = append(allIgnoredColumns, req.SetNullColumns...)
				allIgnoredColumns = append(allIgnoredColumns, req.WhereColumns...)
				setCvs = b.ColumnValues(true, allIgnoredColumns...)
			}
			b.SetOk(false)
			b.EachColumnValues(setCvs, b.Sep(","), func(column string, value any) {
				b.SetOk(true)
				b.Write(column).Write("=").Write(b.Pp(":")).Arg(value)
			})
			if !req.UpdateAll {
				b.EachColumnName(req.SetNullColumns, nil, func(_, _ int, column string) {
					if b.Ok() {
						b.Write(",")
					}
					b.SetOk(true)
					b.Write(column).Write("=NULL")
				})
			}
			b.Write(" WHERE ")
			var whereCond condition
			if len(req.WhereColumns) > 0 {
				a := And()
				for _, c := range req.WhereColumns {
					value := b.ColumnValue(b.Entity(), c)
					if value == nil {
						a.IsNull(c)
					} else {
						a.Eq(c, value)
					}
				}
				if req.Condition != nil {
					a = a.Group(req.Condition)
				}
				whereCond = a
			} else if req.Condition != nil {
				whereCond = req.Condition
			} else {
				b.SetOk(false)
				return
			}
			cb := getConditionBuilder(b)
			whereCond.write(cb)
		}})
}

// UpdateBatch modifies multiple records by a SQL.
func (d baseDao[T]) UpdateBatch(req UpdateBatchReq[T]) (int64, error) {
	return d.Exec(gdao.ExecReq[T]{Ctx: req.Ctx, Entities: req.Entities, BuildSql: func(b *gdao.Builder[T]) {
		b.SetOk(false)
		if req.WhereColumn == "" {
			return
		}
		b.Write("UPDATE ").Write(d.table).Write(" SET ")
		if len(req.SetColumns) == 0 {
			req.SetColumns = b.Columns()
		}
		var allIgnoredColumns []string
		allIgnoredColumns = append(allIgnoredColumns, req.IgnoredColumns...)
		allIgnoredColumns = append(allIgnoredColumns, req.WhereColumn)
		b.EachColumnName(req.SetColumns, b.Sep(","), func(_, _ int, column string) {
			b.SetOk(true)
			b.Write(column).Write("=CASE ").Write(req.WhereColumn)
			b.EachEntity(nil, func(_, _ int, entity *T) {
				b.Write(" WHEN ").Write(b.Pp(":")).Arg(b.ColumnValue(entity, req.WhereColumn)).Write(" THEN ").Write(b.Pp(":")).Arg(b.ColumnValue(entity, column))
			})
			b.Write(" END")
		}, allIgnoredColumns...)
		b.Write(" WHERE ").Write(req.WhereColumn).Write(" IN")
		b.EachEntity(b.SepFix("(", ",", ")", false), func(_, _ int, entity *T) {
			b.Write(b.Pp(":")).Arg(b.ColumnValue(entity, req.WhereColumn))
		})
	}})
}

// Delete removes records.
func (d baseDao[T]) Delete(req DeleteReq) (int64, error) {
	return d.Exec(gdao.ExecReq[T]{Ctx: req.Ctx, BuildSql: func(b *gdao.Builder[T]) {
		b.Write("DELETE FROM ").Write(d.table).Write(" WHERE ")
		cb := getConditionBuilder(b)
		req.Condition.write(cb)
	}})
}

func newBaseDao[T any](req gdao.NewDaoReq, table string) *baseDao[T] {
	dao := gdao.NewDao[T](req)
	table = strings.TrimSpace(table)
	if table == "" {
		panic(`parameter "table" must not be blank`)
	}
	return &baseDao[T]{Dao: dao, table: table}
}

func OrderBy() *orderBy {
	return &orderBy{}
}

func Page(page, pageSize int) *pagination {
	return &pagination{page: page, pageSize: pageSize}
}

func And() *conditionGroup {
	return &conditionGroup{or: false}
}

func Or() *conditionGroup {
	return &conditionGroup{or: true}
}

func NotAnd() *conditionGroup {
	return &conditionGroup{baseCondition: baseCondition{not: true}, or: false}
}

func NotOr() *conditionGroup {
	return &conditionGroup{baseCondition: baseCondition{not: true}, or: true}
}
