package gen

import (
	"bytes"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/jishaocong0910/gdao"
	"golang.org/x/tools/imports"
)

type dbType int

const (
	DB_TYPE_MYSQL dbType = iota + 1
	DB_TYPE_ORACLE
	DB_TYPE_POSTGRES
	DB_TYPE_SQLSERVER
	DB_TYPE_SQLITE
)

type dbBigDecimalMapType int

const (
	DB_BIG_DECIMAL_MAP_TYPE_MATH dbBigDecimalMapType = iota + 1
	DB_BIG_DECIMAL_MAP_TYPE_SHOPSPRING
)

type dialect interface {
	getTableInfo(table string) (bool, []*field, string)
}

type Generator struct {
	c Config
	d dialect
}

func (g Generator) Gen() {
	var entities []entity
	for table, fieldTypes := range g.c.Tables {
		exists, fields, comment := g.d.getTableInfo(table)
		if !exists {
			continue
		}
		e := entity{
			FileName:   g.c.FileNameMapper.AddSuffix(".go").Convert(table),
			Package:    g.getPackageName(),
			EntityName: g.c.EntityNameMapper.Convert(table),
			Fields:     fields,
			Comment:    comment,
		}
		for column, fieldType := range fieldTypes {
			for _, f := range e.Fields {
				if f.Column == column {
					f.FieldType = fieldType
					if strings.HasPrefix(f.FieldType, "[]") {
						if _, ok := supportedFieldTypes[strings.TrimLeft(f.FieldType, "[]")]; !ok {
							f.Valid = false
						}
					} else {
						if !strings.HasPrefix(f.FieldType, "*") {
							f.FieldType = "*" + f.FieldType
						}
						if _, ok := supportedFieldTypes[f.FieldType[1:]]; !ok {
							f.Valid = false
						}
					}
				}
			}
		}
		entities = append(entities, e)
	}
	g.createOutPath()
	for _, e := range entities {
		g.createEntity(e)
	}
}

func (g Generator) createOutPath() {
	path := g.c.OutPath
	wd := mustReturn(os.Getwd())
	filepath.Join(wd, path)
	mustNoError(os.MkdirAll(path, os.ModePerm))
}

func (g Generator) getPackageName() string {
	if g.c.Package != "" {
		return g.c.Package
	}
	paths := filepath.SplitList(g.c.OutPath)
	return paths[len(paths)-1]
}

func (g Generator) createEntity(e entity) {
	var buf bytes.Buffer
	t := mustReturn(template.New("").Parse(entityTemplate))
	mustNoError(t.Execute(&buf, e))
	content := mustReturn(imports.Process("", buf.Bytes(), nil))
	path := filepath.Join(g.c.OutPath, e.FileName)
	os.WriteFile(path, content, 0644)
}

const entityTemplate = `// Code generated by https://github.com/alertego/gdao/gen. YOU CAN EDIT FOR MORE.

package {{.Package}}
{{if ne .Comment ""}}
// {{.EntityName}} {{.Comment}}
{{- end}}
type {{.EntityName}} struct {
{{- range $f := .Fields}}
	// {{$f.FieldName}}{{if ne $f.Comment ""}} {{$f.Comment}}{{end}}
	{{- if not $f.Valid}}
	// gdao cannot solve this type!
	{{- end}}
	{{$f.FieldName}} {{$f.FieldType}} ` +
	"`gdao:\"column={{$f.Column}}" +
	"{{if $f.IsAutoIncrement}};auto{{end}}" +
	"\"`" + `
{{- end}}
}`

type entity struct {
	FileName   string
	Package    string
	EntityName string
	Fields     []*field
	Comment    string
}

type field struct {
	Column          string
	FieldName       string
	FieldType       string
	IsAutoIncrement bool
	Comment         string
	Valid           bool
}

type Config struct {
	// 必填，数据库类型
	DbType dbType
	// 必填，数据源链接
	Dsn string
	// 必填, 生成路径，绝对路径为os.Getwd()/OutPath
	OutPath string
	// 可选, 包名，默认为目录名
	Package string
	// 可选，需要生成的表，和强制指定映射类型
	Tables Tables
	// 可选，表->文件 名称映射
	FileNameMapper *gdao.NameMapper
	// 可选，表->实体 名称映射
	EntityNameMapper *gdao.NameMapper
	// 可选，表字段->实体字段 名称映射
	FieldNameMapper *gdao.NameMapper
}

type Tables map[string]FieldTypes

type FieldTypes map[string]string

func GetGenerator(c Config) Generator {
	if c.FileNameMapper == nil {
		c.FileNameMapper = gdao.NewNameMapper().LowerSnakeCase()
	}
	if c.EntityNameMapper == nil {
		c.EntityNameMapper = gdao.NewNameMapper().UpperCamelCase()
	}
	if c.FieldNameMapper == nil {
		c.FieldNameMapper = gdao.NewNameMapper().UpperCamelCase()
	}
	var d dialect
	switch c.DbType {
	case DB_TYPE_MYSQL:
		d = newMySqlGenerator(c)
	case DB_TYPE_ORACLE:
		d = newOracleGenerator(c)
	case DB_TYPE_POSTGRES:
		d = newPostgresGenerator(c)
	case DB_TYPE_SQLSERVER:
		d = newSqlServerGenerator(c)
	case DB_TYPE_SQLITE:
		d = newSqliteGenerator(c)
	default:
		panic("not support this db type yet")
	}
	return Generator{c: c, d: d}
}

func mustNoError(err error) {
	if err != nil { // coverage-ignore
		panic(err)
	}
}

func mustReturn[T any](t T, err error) T {
	if err != nil { // coverage-ignore
		panic(err)
	}
	return t
}

var supportedFieldTypes = map[string]struct{}{
	"bool": {}, "string": {}, "time.Time": {}, "float32": {}, "float64": {}, "int": {}, "int8": {}, "int16": {}, "int32": {}, "int64": {}, "uint": {}, "uint8": {}, "uint16": {}, "uint32": {}, "uint64": {},
}
