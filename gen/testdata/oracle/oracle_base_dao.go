// Code generated by https://github.com/jishaocong0910/gdao. YOU CAN EDIT FOR MORE.

package dao

import (
	"context"
	"database/sql"
	"strconv"
	"strings"

	"github.com/jishaocong0910/gdao"
)

type ListReq struct {
	Ctx context.Context
	Tx  *sql.Tx
	// specify the columns which in the select column list, default is all columns.
	SelectColumns []string
	// conditions of the WHERE clause，create by function And, Or, NotAnd and NotOr.
	Condition *conditionGroup
	// ORDER BY clause，create by function OrderBy.
	OrderBy *orderBy
	// paging query，create by function Page.
	Pagination *pagination
	// FOR UPDATE clause
	ForUpdate bool
}

type GetReq struct {
	Ctx context.Context
	Tx  *sql.Tx
	// specify the columns which in the select column list, default is all columns.
	SelectColumns []string
	// conditions of the WHERE clause，create by function And, Or, NotAnd and NotOr.
	Condition *conditionGroup
	// FOR UPDATE clause
	ForUpdate bool
}

type InsertReq[T any] struct {
	Ctx context.Context
	Tx  *sql.Tx
	// the non-nil fields will be saved, and the auto generated keys will be set in it.
	Entity *T
	// if true, all fields will be saved, otherwise, save non-nil fields.
	InsertAll bool
	// specify the columns which save a null value, it will not work when UpdateAll is true
	SetNullColumns []string
}

type InsertBatchReq[T any] struct {
	Ctx context.Context
	Tx  *sql.Tx
	// each element corresponds to a record to be saved, and the auto generated keys will be set in them.
	Entities []*T
	// specify the columns which be ignored from the insert column list.
	IgnoredColumns []string
}

type UpdateReq[T any] struct {
	Ctx context.Context
	Tx  *sql.Tx
	// uses to update values or as the WHERE clause conditions.
	Entity *T
	// if true, all fields will be updated, otherwise, update non-nil fields.
	UpdateAll bool
	// specify the columns update to null, it will not work when UpdateAll is true
	SetNullColumns []string
	// specify the non-nil fields in the entity used as conditions.
	WhereColumns []string
	// conditions of the WHERE clause，create by function And, Or, NotAnd and NotOr..
	Condition *conditionGroup
}

type UpdateBatchReq[T any] struct {
	Ctx context.Context
	Tx  *sql.Tx
	// each element corresponds to a record to be updated.
	Entities []*T
	// specify the columns which in the set list, default is all columns.
	SetColumns []string
	// specify the columns which be ignored from set list.
	IgnoredColumns []string
	// specify the column which used as a condition.
	WhereColumn string
}

type DeleteReq struct {
	Ctx context.Context
	Tx  *sql.Tx
	// conditions of the WHERE clause，create by function And, Or, NotAnd and NotOr.
	Condition *conditionGroup
}

type orderBy struct {
	Items []orderByItem
}

func (o *orderBy) Asc(column string) *orderBy {
	o.Items = append(o.Items, orderByItem{Column: column, Sequence: asc})
	return o
}

func (o *orderBy) Desc(column string) *orderBy {
	o.Items = append(o.Items, orderByItem{Column: column, Sequence: desc})
	return o
}

type orderBySequence string

const (
	asc  orderBySequence = "ASC"
	desc                 = "DESC"
)

type orderByItem struct {
	Column   string
	Sequence orderBySequence
}

type pagination struct {
	page, pageSize int64
}

type conditionBuilder struct {
	write func(str string, args ...any)
	pp    func(prefix string) string
}

func getConditionBuilder[T any](b *gdao.Builder[T]) conditionBuilder {
	return conditionBuilder{
		write: func(str string, args ...any) {
			b.Write(str, args...)
		},
		pp: func(prefix string) string {
			return b.Pp(prefix)
		},
	}
}

type condition interface {
	write(b conditionBuilder) bool
}

type baseCondition struct {
	not           bool
	parenthesized bool
}

func (c baseCondition) doWrite(b conditionBuilder, customWrite func()) {
	if c.not {
		b.write("NOT ")
	}
	if c.parenthesized {
		b.write("(")
	}
	customWrite()
	if c.parenthesized {
		b.write(")")
	}
}

type conditionGroup struct {
	baseCondition
	or      bool
	nextNot bool
	cs      []condition
}

func (c *conditionGroup) write(b conditionBuilder) bool {
	if c == nil || len(c.cs) == 0 {
		return false
	}
	var ok bool
	c.doWrite(b, func() {
		for _, cond := range c.cs {
			if ok {
				if c.or {
					b.write(" OR ")
				} else {
					b.write(" AND ")
				}
			}
			written := cond.write(b)
			if !ok {
				ok = written
			}
		}
	})
	return ok
}

func (c *conditionGroup) Eq(column string, arg any) *conditionGroup {
	c.cs = append(c.cs, conditionBinOp{baseCondition: baseCondition{not: c.nextNot}, column: column, op: "=", arg: arg})
	if len(c.cs) > 1 && c.not {
		c.parenthesized = true
	}
	return c
}

func (c *conditionGroup) NotEq(column string, arg any) *conditionGroup {
	c.cs = append(c.cs, conditionBinOp{baseCondition: baseCondition{not: c.nextNot}, column: column, op: "<>", arg: arg})
	return c
}

func (c *conditionGroup) Gt(column string, arg any) *conditionGroup {
	c.cs = append(c.cs, conditionBinOp{baseCondition: baseCondition{not: c.nextNot}, column: column, op: ">", arg: arg})
	return c
}

func (c *conditionGroup) Lt(column string, arg any) *conditionGroup {
	c.cs = append(c.cs, conditionBinOp{baseCondition: baseCondition{not: c.nextNot}, column: column, op: "<", arg: arg})
	return c
}

func (c *conditionGroup) GtEq(column string, arg any) *conditionGroup {
	c.cs = append(c.cs, conditionBinOp{baseCondition: baseCondition{not: c.nextNot}, column: column, op: ">=", arg: arg})
	return c
}

func (c *conditionGroup) LtEq(column string, arg any) *conditionGroup {
	c.cs = append(c.cs, conditionBinOp{baseCondition: baseCondition{not: c.nextNot}, column: column, op: "<=", arg: arg})
	return c
}

func (c *conditionGroup) Like(column string, arg string) *conditionGroup {
	c.cs = append(c.cs, conditionBinOp{baseCondition: baseCondition{not: c.nextNot}, column: column, op: " LIKE ", arg: "%" + arg + "%"})
	return c
}

func (c *conditionGroup) LikeLeft(column string, arg string) *conditionGroup {
	c.cs = append(c.cs, conditionBinOp{baseCondition: baseCondition{not: c.nextNot}, column: column, op: " LIKE ", arg: arg + "%"})
	return c
}

func (c *conditionGroup) LikeRight(column string, arg string) *conditionGroup {
	c.cs = append(c.cs, conditionBinOp{baseCondition: baseCondition{not: c.nextNot}, column: column, op: " LIKE ", arg: "%" + arg})
	return c
}

func (c *conditionGroup) In(column string, args ...any) *conditionGroup {
	c.cs = append(c.cs, conditionIn{baseCondition: baseCondition{not: c.nextNot}, column: column, args: args})
	return c
}

func (c *conditionGroup) Between(column string, min, max any) *conditionGroup {
	c.cs = append(c.cs, conditionBetween{baseCondition: baseCondition{not: c.nextNot}, column: column, min: min, max: max})
	return c
}

func (c *conditionGroup) IsNull(column string) *conditionGroup {
	c.cs = append(c.cs, conditionIsNull{baseCondition: baseCondition{not: c.nextNot}, column: column})
	return c
}

func (c *conditionGroup) IsNotNull(column string) *conditionGroup {
	c.cs = append(c.cs, conditionIsNull{baseCondition: baseCondition{not: c.nextNot}, column: column, notNull: true})
	return c
}

func (c *conditionGroup) And(other *conditionGroup) *conditionGroup {
	if other == nil || len(c.cs) == 0 {
		return c
	}
	merge := &conditionGroup{}
	if len(c.cs) > 0 {
		merge.cs = append(merge.cs, c)
		if c.or && len(c.cs) > 1 {
			c.parenthesized = true
		}
	}
	merge.cs = append(merge.cs, other)
	if other.or && len(other.cs) > 1 {
		other.parenthesized = true
	}
	return merge
}

func (c *conditionGroup) Or(other *conditionGroup) *conditionGroup {
	if other == nil || len(c.cs) == 0 {
		return c
	}
	merge := &conditionGroup{}
	if len(c.cs) > 0 {
		merge.cs = append(merge.cs, c)
	}
	merge.cs = append(merge.cs, other)
	return merge
}

type conditionBinOp struct {
	baseCondition
	column string
	op     string
	arg    any
}

func (c conditionBinOp) write(b conditionBuilder) bool {
	c.doWrite(b, func() {
		b.write(c.column)
		b.write(c.op)
		b.write(b.pp(":"), c.arg)
	})
	return true
}

type conditionIn struct {
	baseCondition
	column string
	args   []any
}

func (c conditionIn) write(b conditionBuilder) bool {
	c.doWrite(b, func() {
		b.write(c.column)
		b.write(" IN(")
		for i := 0; i < len(c.args); i++ {
			if i != 0 {
				b.write(",")
			}
			b.write(b.pp(":"))
		}
		b.write(")", c.args...)
	})
	return true
}

type conditionIsNull struct {
	baseCondition
	notNull bool
	column  string
}

func (c conditionIsNull) write(b conditionBuilder) bool {
	c.doWrite(b, func() {
		b.write(c.column)
		b.write(" IS")
		if c.notNull {
			b.write(" NOT")
		}
		b.write(" NULL")
	})
	return true
}

type conditionBetween struct {
	baseCondition
	column   string
	min, max any
}

func (c conditionBetween) write(b conditionBuilder) bool {
	c.doWrite(b, func() {
		b.write(c.column)
		b.write(" BETWEEN ")
		b.write(b.pp(":"))
		b.write(" AND ")
		b.write(b.pp(":"), c.min, c.max)
	})
	return true
}

type baseDao[T any] struct {
	*gdao.Dao[T]
	table string
}

// List queries records of the conditions, it won't execute if there is no condition.
func (d baseDao[T]) List(req ListReq) ([]*T, error) {
	_, list, err := d.Query(gdao.QueryReq[T]{Ctx: req.Ctx, Tx: req.Tx, BuildSql: func(b *gdao.Builder[T]) {
		if req.Condition == nil {
			b.SetOk(false)
			return
		}
		b.Write("SELECT ").WriteColumns(req.SelectColumns...).Write(" FROM ").Write(d.table).Write(" WHERE ")
		cb := getConditionBuilder(b)
		b.SetOk(req.Condition.write(cb))
		if !b.Ok() {
			return
		}
		if req.OrderBy != nil {
			b.Repeat(len(req.OrderBy.Items), b.SepFix(" ORDER BY ", ",", "", false), nil, func(n, i int) {
				item := req.OrderBy.Items[i]
				b.Write(item.Column).Write(" ")
				b.Write(string(item.Sequence))
			})
		}
		if req.Pagination != nil {
			page := req.Pagination.page
			pageSize := req.Pagination.pageSize
			if page > 0 && pageSize > 0 {
				b.Write(" OFFSET ")
				b.Write(strconv.FormatInt((page-1)*pageSize, 10))
				b.Write(" FETCH NEXT ")
				b.Write(strconv.FormatInt(pageSize, 10))
				b.Write(" ROWS ONLY")
			}
		}
		if req.ForUpdate {
			b.Write(" FOR UPDATE")
		}
	}})
	return list, err
}

// Get queries a record of the conditions, it won't execute if there is no condition.
func (d baseDao[T]) Get(req GetReq) (*T, error) {
	first, _, err := d.Query(gdao.QueryReq[T]{Ctx: req.Ctx, Tx: req.Tx, BuildSql: func(b *gdao.Builder[T]) {
		if req.Condition == nil {
			b.SetOk(false)
			return
		}
		b.Write("SELECT ").WriteColumns(req.SelectColumns...).Write(" FROM ").Write(d.table).Write(" WHERE ")
		cb := getConditionBuilder(b)
		b.SetOk(req.Condition.write(cb))
		if !b.Ok() {
			return
		}
		b.Write(" FETCH NEXT 1 ROWS ONLY")
		if req.ForUpdate {
			b.Write(" FOR UPDATE")
		}
	}})
	return first, err
}

// Insert saves a record and return the auto generated keys.
func (d baseDao[T]) Insert(req InsertReq[T]) (int64, error) {
	return d.Exec(gdao.ExecReq[T]{Ctx: req.Ctx, Tx: req.Tx, Entities: []*T{req.Entity},
		BuildSql: func(b *gdao.Builder[T]) {
			var entityFieldNum, setNullColumnNum int
			b.Write("INSERT INTO ").Write(d.table).Write("(")
			var cvs []gdao.ColumnValue
			if req.InsertAll {
				cvs = b.ColumnValues(false)
			} else {
				cvs = b.ColumnValues(true)
			}
			b.SetOk(false)
			b.EachColumnValues(cvs, b.Sep(","), func(column string, value any) {
				b.SetOk(true)
				entityFieldNum++
				b.Write(column, value)
			})
			if !req.InsertAll {
				b.EachColumnName(req.SetNullColumns, nil, func(_, _ int, column string) {
					if b.Ok() {
						b.Write(",")
					}
					b.SetOk(true)
					setNullColumnNum++
					b.Write(column)
				})
			}
			b.Write(")")
			b.Repeat(entityFieldNum+setNullColumnNum, b.SepFix(" VALUES(", ",", ")", false), nil, func(n, i int) {
				if i < entityFieldNum {
					b.Write(b.Pp(":"))
				} else {
					b.Write("NULL")
				}
			})
			if len(b.AutoColumns()) == 1 {
				b.Write("; SELECT ID=convert(bigint, SCOPE_IDENTITY())")
			}
		}})
}

// InsertBatch saves records and return the auto generated keys.
func (d baseDao[T]) InsertBatch(req InsertBatchReq[T]) (int64, error) {
	return d.Exec(gdao.ExecReq[T]{Ctx: req.Ctx, Tx: req.Tx, Entities: req.Entities,
		BuildSql: func(b *gdao.Builder[T]) {
			var allIgnoredColumns []string
			allIgnoredColumns = append(allIgnoredColumns, req.IgnoredColumns...)
			allIgnoredColumns = append(allIgnoredColumns, b.AutoColumns()...)
			b.Write("INSERT INTO ").Write(d.table)
			b.EachColumnName(b.Columns(), b.SepFix("(", ",", ")", false), func(_, _ int, column string) {
				b.Write(column)
			}, allIgnoredColumns...)
			b.Write(" VALUES")
			b.EachEntity(b.Sep(","), func(_, _ int, entity *T) {
				cvs := b.ColumnValuesAt(entity, false, allIgnoredColumns...)
				b.EachColumnValues(cvs, b.SepFix("(", ",", ")", false), func(column string, value any) {
					b.Write(b.Pp(":")).Arg(value)
				})
			})
			if len(b.AutoColumns()) == 1 {
				b.Write("; SELECT ID=convert(bigint, SCOPE_IDENTITY())")
			}
		}})
}

// Update modifies a record, it won't execute if there is no column to set or no condition.
func (d baseDao[T]) Update(req UpdateReq[T]) (int64, error) {
	return d.Exec(gdao.ExecReq[T]{Ctx: req.Ctx, Tx: req.Tx, Entities: []*T{req.Entity},
		BuildSql: func(b *gdao.Builder[T]) {
			b.Write("UPDATE ").Write(d.table).Write(" SET ")
			var setCvs []gdao.ColumnValue
			if req.UpdateAll {
				setCvs = b.ColumnValues(false, req.WhereColumns...)
			} else {
				var allIgnoredColumns []string
				allIgnoredColumns = append(allIgnoredColumns, req.SetNullColumns...)
				allIgnoredColumns = append(allIgnoredColumns, req.WhereColumns...)
				setCvs = b.ColumnValues(true, allIgnoredColumns...)
			}
			b.SetOk(false)
			b.EachColumnValues(setCvs, b.Sep(","), func(column string, value any) {
				b.SetOk(true)
				b.Write(column).Write("=").Write(b.Pp(":")).Arg(value)
			})
			if !req.UpdateAll {
				b.EachColumnName(req.SetNullColumns, nil, func(_, _ int, column string) {
					if b.Ok() {
						b.Write(",")
					}
					b.SetOk(true)
					b.Write(column).Write("=NULL")
				})
			}
			b.Write(" WHERE ")
			var whereCond condition
			if len(req.WhereColumns) > 0 {
				a := And()
				for _, c := range req.WhereColumns {
					value := b.ColumnValue(b.Entity(), c)
					if value == nil {
						a.IsNull(c)
					} else {
						a.Eq(c, value)
					}
				}
				if req.Condition != nil {
					a = a.And(req.Condition)
				}
				whereCond = a
			} else if req.Condition != nil {
				whereCond = req.Condition
			} else {
				b.SetOk(false)
				return
			}
			cb := getConditionBuilder(b)
			b.SetOk(whereCond.write(cb))
		}})
}

// UpdateBatch modifies multiple records by a SQL, it won't execute if there is no condition.
func (d baseDao[T]) UpdateBatch(req UpdateBatchReq[T]) (int64, error) {
	return d.Exec(gdao.ExecReq[T]{Ctx: req.Ctx, Tx: req.Tx, Entities: req.Entities, BuildSql: func(b *gdao.Builder[T]) {
		b.SetOk(false)
		if req.WhereColumn == "" {
			return
		}
		b.Write("UPDATE ").Write(d.table).Write(" SET ")
		if len(req.SetColumns) == 0 {
			req.SetColumns = b.Columns()
		}
		var allIgnoredColumns []string
		allIgnoredColumns = append(allIgnoredColumns, req.IgnoredColumns...)
		allIgnoredColumns = append(allIgnoredColumns, req.WhereColumn)
		b.EachColumnName(req.SetColumns, b.Sep(","), func(_, _ int, column string) {
			b.SetOk(true)
			b.Write(column).Write("=CASE ").Write(req.WhereColumn)
			b.EachEntity(nil, func(_, _ int, entity *T) {
				b.Write(" WHEN ").Write(b.Pp(":")).Arg(b.ColumnValue(entity, req.WhereColumn)).Write(" THEN ").Write(b.Pp(":")).Arg(b.ColumnValue(entity, column))
			})
			b.Write(" END")
		}, allIgnoredColumns...)
		b.Write(" WHERE ").Write(req.WhereColumn).Write(" IN")
		b.EachEntity(b.SepFix("(", ",", ")", false), func(_, _ int, entity *T) {
			b.Write(b.Pp(":")).Arg(b.ColumnValue(entity, req.WhereColumn))
		})
	}})
}

// Delete removes records, it won't execute if there is no conditions.
func (d baseDao[T]) Delete(req DeleteReq) (int64, error) {
	return d.Exec(gdao.ExecReq[T]{Ctx: req.Ctx, Tx: req.Tx, BuildSql: func(b *gdao.Builder[T]) {
		b.Write("DELETE FROM ").Write(d.table).Write(" WHERE ")
		cb := getConditionBuilder(b)
		b.SetOk(req.Condition.write(cb))
	}})
}

func newBaseDao[T any](req gdao.NewDaoReq, table string) *baseDao[T] {
	dao := gdao.NewDao[T](req)
	table = strings.TrimSpace(table)
	if table == "" {
		panic("table must not be blank")
	}
	return &baseDao[T]{Dao: dao, table: table}
}

func OrderBy() *orderBy {
	return &orderBy{}
}

func Page(page, pageSize int64) *pagination {
	return &pagination{page: page, pageSize: pageSize}
}

func And() *conditionGroup {
	return &conditionGroup{or: false}
}

func Or() *conditionGroup {
	return &conditionGroup{or: true}
}

func NotAnd() *conditionGroup {
	return &conditionGroup{baseCondition: baseCondition{not: true}, or: false}
}

func NotOr() *conditionGroup {
	return &conditionGroup{baseCondition: baseCondition{not: true}, or: true}
}
