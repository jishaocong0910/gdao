// Code generated by https://github.com/jishaocong0910/gdao. FOR SQLite. DO NOT EDIT.

package {{.PkgName}}

import (
	"context"
	"database/sql"
	"errors"
	"strconv"
	"strings"

	"github.com/jishaocong0910/gdao"
)

type list[T any] struct {
	// the base dao
	dao *baseDao[T]
	// the context
	ctx context.Context
	// if true, panic when error occurs, otherwise, return error.
	must bool
	// specify the log level
	logLevel gdao.LogLevel
	// describe the sql in the log
	desc string
	// specify the columns which in the select column list, default is all columns.
	sel []string
	// conditions of the where clause，create by function And, Or and Not.
	condition Cond
	// ORDER BY clause，create by function OrderBy.
	orderBy *orderBy
	// paging query，create by function Page.
	page *page
	// FOR UPDATE clause
	forUpdate bool
}

func (l *list[T]) Ctx(ctx context.Context) *list[T] {
	l.ctx = ctx
	return l
}

func (l *list[T]) Must(must bool) *list[T] {
	l.must = must
	return l
}

func (l *list[T]) LogLevel(logLevel gdao.LogLevel) *list[T] {
	l.logLevel = logLevel
	return l
}

func (l *list[T]) Desc(desc string) *list[T] {
	l.desc = desc
	return l
}

func (l *list[T]) Select(sel ...string) *list[T] {
	l.sel = mapColumns(l.dao.NameMap(), sel)
	return l
}

func (l *list[T]) Condition(cond Cond) *list[T] {
	l.condition = cond
	return l
}

func (l *list[T]) Orderby(orderBy *orderBy) *list[T] {
	l.orderBy = orderBy
	return l
}

func (l *list[T]) Page(page *page) *list[T] {
	l.page = page
	return l
}

func (l *list[T]) ForUpdate(forUpdate bool) *list[T] {
	l.forUpdate = forUpdate
	return l
}

func (l *list[T]) Do() ([]*T, error) {
	_, list, err := l.dao.Query().Ctx(l.ctx).Must(l.must).LogLevel(l.logLevel).Desc(l.desc).BuildSql(func(b *gdao.DaoSqlBuilder[T]) {
		b.Write("SELECT ").WriteColumns(l.sel...).Write(" FROM ").Write(l.dao.table)
		if l.condition != nil && l.condition.len() > 0 {
			b.Write(" WHERE ")
			l.condition.write(l.dao.NameMap(), b.BaseSqlBuilder)
		}
		if l.orderBy != nil {
			l.orderBy.write(l.dao.NameMap(), b.BaseSqlBuilder)
		}
		if l.page != nil {
			b.Write(" LIMIT ")
			b.Write(strconv.FormatInt(int64(l.page.pageSize), 10))
			if l.page.offset > 0 {
				b.Write(" OFFSET ")
				b.Write(strconv.FormatInt(int64(l.page.offset), 10))
			}
		}
		if l.forUpdate {
			b.Write(" FOR UPDATE")
		}
	}).Do()
	return list, err
}

type get[T any] struct {
	// the base dao
	dao *baseDao[T]
	// the context
	ctx context.Context
	// if true, panic when error occurs, otherwise, return error.
	must bool
	// specify the log level
	logLevel gdao.LogLevel
	// describe the SQL in the log
	desc string
	// specify the columns which in the select column list, default is all columns.
	sel []string
	// conditions of the WHERE clause，create by function And, Or and Not.
	condition Cond
	// ORDER BY clause，create by function OrderBy.
	orderBy *orderBy
	// FOR UPDATE clause
	forUpdate bool
	// must return one row, default is false
	checkOne bool
}

func (g *get[T]) Ctx(ctx context.Context) *get[T] { // coverage-ignore
	g.ctx = ctx
	return g
}

func (g *get[T]) Must(must bool) *get[T] { // coverage-ignore
	g.must = must
	return g
}

func (g *get[T]) LogLevel(logLevel gdao.LogLevel) *get[T] { // coverage-ignore
	g.logLevel = logLevel
	return g
}

func (g *get[T]) Desc(desc string) *get[T] { // coverage-ignore
	g.desc = desc
	return g
}

func (g *get[T]) Select(sel ...string) *get[T] {
	g.sel = mapColumns(g.dao.NameMap(), sel)
	return g
}

func (g *get[T]) Condition(cond Cond) *get[T] {
	g.condition = cond
	return g
}

func (g *get[T]) Orderby(orderBy *orderBy) *get[T] {
	g.orderBy = orderBy
	return g
}

func (g *get[T]) ForUpdate(forUpdate bool) *get[T] {
	g.forUpdate = forUpdate
	return g
}

func (g *get[T]) CheckOne(checkOne bool) *get[T] {
	g.checkOne = checkOne
	return g
}

func (g *get[T]) Do() (*T, error) {
	list, err := g.dao.List().Ctx(g.ctx).Must(g.must).LogLevel(g.logLevel).Desc(g.desc).
		Select(g.sel...).Condition(g.condition).Orderby(g.orderBy).ForUpdate(g.forUpdate).Do()
	if len(list) == 0 { // coverage-ignore
		return nil, err
	}
	if g.checkOne && len(list) > 1 {
		err = errors.New("return more than one row")
		if g.must { // coverage-ignore
			panic(err)
		}
	}
	return list[0], err
}

type insert[T any] struct {
	// the base dao
	dao *baseDao[T]
	// the context
	ctx context.Context
	// if true, panic when error occurs, otherwise, return error.
	must bool
	// specify the log level
	logLevel gdao.LogLevel
	// describe the SQL in the log
	desc string
	// the non-nil fields will be saved, and the auto generated keys will be set in it.
	entity *T
	// if true, all fields will be saved, otherwise, save non-nil fields.
	all bool
	// specify the columns which set a null value
	setNull []string
	// specify the columns which don't be set
	ignore []string
}

func (i *insert[T]) Ctx(ctx context.Context) *insert[T] { // coverage-ignore
	i.ctx = ctx
	return i
}

func (i *insert[T]) Must(must bool) *insert[T] { // coverage-ignore
	i.must = must
	return i
}

func (i *insert[T]) LogLevel(logLevel gdao.LogLevel) *insert[T] { // coverage-ignore
	i.logLevel = logLevel
	return i
}

func (i *insert[T]) Desc(desc string) *insert[T] { // coverage-ignore
	i.desc = desc
	return i
}

func (i *insert[T]) Entity(entity *T) *insert[T] {
	i.entity = entity
	return i
}

func (i *insert[T]) All(all bool) *insert[T] {
	i.all = all
	return i
}

func (i *insert[T]) SetNull(setNull ...string) *insert[T] {
	i.setNull = mapColumns(i.dao.NameMap(), setNull)
	return i
}

func (i *insert[T]) Ignore(ignore ...string) *insert[T] {
	i.ignore = mapColumns(i.dao.NameMap(), ignore)
	return i
}

func (i *insert[T]) Do() (int64, error) {
	return i.dao.InsertBatch().Ctx(i.ctx).Must(i.must).LogLevel(i.logLevel).Desc(i.desc).Entities(i.entity).All(i.all).
		SetNull(i.setNull...).Ignore(i.ignore...).Do()
}

type insertBatch[T any] struct {
	// the base dao
	dao *baseDao[T]
	// the context
	ctx context.Context
	// if true, panic when error occurs, otherwise, return error.
	must bool
	// specify the log level
	logLevel gdao.LogLevel
	// describe the SQL in the log
	desc string
	// each element corresponds to a record to be saved, and the auto generated keys will be set in them.
	entities []*T
	// if true, all fields will be saved, otherwise, save non-nil fields.
	all bool
	// specify the columns which set a null value
	setNull []string
	// specify the columns which don't be set
	ignore []string
}

func (ib *insertBatch[T]) Ctx(ctx context.Context) *insertBatch[T] {
	ib.ctx = ctx
	return ib
}

func (ib *insertBatch[T]) Must(must bool) *insertBatch[T] {
	ib.must = must
	return ib
}

func (ib *insertBatch[T]) LogLevel(logLevel gdao.LogLevel) *insertBatch[T] {
	ib.logLevel = logLevel
	return ib
}

func (ib *insertBatch[T]) Desc(desc string) *insertBatch[T] {
	ib.desc = desc
	return ib
}

func (ib *insertBatch[T]) Entities(entities ...*T) *insertBatch[T] {
	ib.entities = entities
	return ib
}

func (ib *insertBatch[T]) All(all bool) *insertBatch[T] {
	ib.all = all
	return ib
}

func (ib *insertBatch[T]) SetNull(setNull ...string) *insertBatch[T] {
	ib.setNull = mapColumns(ib.dao.NameMap(), setNull)
	return ib
}

func (ib *insertBatch[T]) Ignore(ignore ...string) *insertBatch[T] {
	ib.ignore = mapColumns(ib.dao.NameMap(), ignore)
	return ib
}

func (ib *insertBatch[T]) Do() (int64, error) {
	return ib.dao.Exec().Ctx(ib.ctx).Must(ib.must).LogLevel(ib.logLevel).Desc(ib.desc).Entities(ib.entities...).
		LastInsertIdAs(gdao.LastInsertIdAs_.LAST_ID).BuildSql(func(b *gdao.DaoSqlBuilder[T]) {
		var setColumnNum, setNullColumnNum int
		var allIgnore []string
		allIgnore = append(allIgnore, ib.setNull...)
		allIgnore = append(allIgnore, ib.ignore...)
		allIgnore = append(allIgnore, b.AutoColumns()...)

		b.Write("INSERT INTO ").Write(ib.dao.table)
		columns := b.Columns(!ib.all, allIgnore...)
		b.Repeat(len(columns), b.SepFix("(", ", ", "", true), nil, func(_, i int) {
			setColumnNum++
			b.Write(columns[i])
		})
		if len(ib.setNull) > 0 {
			if setColumnNum > 0 {
				b.Write(", ")
			}
			b.Repeat(len(ib.setNull), b.Sep(", "), nil, func(_, i int) {
				setNullColumnNum++
				b.Write(ib.setNull[i])
			})
		}
		b.Write(")")
		b.Write(" VALUES")
		b.EachEntity(b.Sep(", "), func(_ int, entity *T) {
			b.EachColumn(entity, b.SepFix("(", ", ", "", true), func(_ int, column string, value any) {
				if value != nil {
					b.Write("?", value)
				} else {
					b.Write("NULL")
				}
			}, columns...)
			if len(ib.setNull) > 0 {
				if setColumnNum > 0 {
					b.Write(", ")
				}
				b.Repeat(len(ib.setNull), b.Sep(", "), nil, func(_, i int) {
					b.Write("NULL")
				})
			}
			b.Write(")")
		})
	}).Do()
}

type update[T any] struct {
	// the base dao
	dao *baseDao[T]
	// the context
	ctx context.Context
	// if true, panic when error occurs, otherwise, return error.
	must bool
	// specify the log level
	logLevel gdao.LogLevel
	// describe the SQL in the log
	desc string
	// uses to update values or the WHERE clause conditions.
	entity *T
	// if true, all fields will be updated, otherwise, update non-nil fields.
	all bool
	// specify the columns which set a null value
	setNull []string
	// specify the columns which don't be set
	ignore []string
	// specify the non-nil fields in the entity used as conditions.
	where []string
	// conditions of the WHERE clause，create by function And, Or and Not..
	condition Cond
}

func (u *update[T]) Ctx(ctx context.Context) *update[T] { // coverage-ignore
	u.ctx = ctx
	return u
}

func (u *update[T]) Must(must bool) *update[T] { // coverage-ignore
	u.must = must
	return u
}

func (u *update[T]) LogLevel(logLevel gdao.LogLevel) *update[T] { // coverage-ignore
	u.logLevel = logLevel
	return u
}

func (u *update[T]) Desc(desc string) *update[T] { // coverage-ignore
	u.desc = desc
	return u
}

func (u *update[T]) Entity(entity *T) *update[T] {
	u.entity = entity
	return u
}

func (u *update[T]) All(all bool) *update[T] {
	u.all = all
	return u
}

func (u *update[T]) SetNull(setNull ...string) *update[T] {
	u.setNull = mapColumns(u.dao.NameMap(), setNull)
	return u
}

func (u *update[T]) Ignore(ignore ...string) *update[T] {
	u.ignore = mapColumns(u.dao.NameMap(), ignore)
	return u
}

func (u *update[T]) Where(where ...string) *update[T] {
	u.where = mapColumns(u.dao.NameMap(), where)
	return u
}

func (u *update[T]) Condition(cond Cond) *update[T] {
	u.condition = cond
	return u
}

func (u *update[T]) Do() (int64, error) {
	return u.dao.Exec().Ctx(u.ctx).Must(u.must).LogLevel(u.logLevel).Desc(u.desc).Entities(u.entity).BuildSql(func(b *gdao.DaoSqlBuilder[T]) {
		var setColumnNum, setNullColumnNum int
		var allIgnore []string
		allIgnore = append(allIgnore, u.setNull...)
		allIgnore = append(allIgnore, u.ignore...)
		allIgnore = append(allIgnore, u.where...)

		b.Write("UPDATE ").Write(u.dao.table).Write(" SET ")
		columns := b.Columns(!u.all, allIgnore...)
		b.EachColumn(b.Entity(), b.SepFix("", ", ", "", true), func(_ int, column string, value any) {
			setColumnNum++
			b.Write(column).Write(" = ")
			if value != nil {
				b.Write("?").SetArgs(value)
			} else {
				b.Write("NULL")
			}
		}, columns...)
		if len(u.setNull) > 0 {
			if setColumnNum > 0 {
				b.Write(", ")
			}
			b.Repeat(len(u.setNull), b.Sep(", "), nil, func(_, i int) {
				setNullColumnNum++
				b.Write(u.setNull[i]).Write(" = NULL")
			})
		}
		cond := And()
		if len(u.where) > 0 {
			b.EachColumn(b.Entity(), nil, func(_ int, column string, value any) {
				if value == nil {
					cond.IsNull(column)
				} else {
					cond.Eq(column, value)
				}
			}, u.where...)
		}
		cond.addCond(u.condition)
		if cond.len() > 0 {
			b.Write(" WHERE ")
			cond.write(u.dao.NameMap(), b.BaseSqlBuilder)
		}
	}).Do()
}

type updateBatch[T any] struct {
	// the base dao
	dao *baseDao[T]
	// the context
	ctx context.Context
	// if true, panic when error occurs, otherwise, return error.
	must bool
	// specify the log level
	logLevel gdao.LogLevel
	// describe the SQL in the log
	desc string
	// each element corresponds to a record to be updated.
	entities []*T
	// if true, all fields will be updated, otherwise, update non-nil fields.
	all bool
	// specify the columns which set a null value
	setNull []string
	// specify the columns which don't be set
	ignore []string
	// specify the column which used as a condition.
	where string
	// conditions of the WHERE clause，create by function And, Or and Not..
	condition Cond
}

func (u *updateBatch[T]) Ctx(ctx context.Context) *updateBatch[T] { // coverage-ignore
	u.ctx = ctx
	return u
}

func (u *updateBatch[T]) Must(must bool) *updateBatch[T] { // coverage-ignore
	u.must = must
	return u
}

func (u *updateBatch[T]) LogLevel(logLevel gdao.LogLevel) *updateBatch[T] { // coverage-ignore
	u.logLevel = logLevel
	return u
}

func (u *updateBatch[T]) Desc(desc string) *updateBatch[T] { // coverage-ignore
	u.desc = desc
	return u
}

func (u *updateBatch[T]) Entities(entities ...*T) *updateBatch[T] {
	u.entities = entities
	return u
}

func (u *updateBatch[T]) All(all bool) *updateBatch[T] {
	u.all = all
	return u
}

func (u *updateBatch[T]) SetNull(setNull ...string) *updateBatch[T] {
	u.setNull = mapColumns(u.dao.NameMap(), setNull)
	return u
}

func (u *updateBatch[T]) Ignore(ignore ...string) *updateBatch[T] {
	u.ignore = mapColumns(u.dao.NameMap(), ignore)
	return u
}

func (u *updateBatch[T]) Where(where string) *updateBatch[T] {
	u.where = mapColumn(u.dao.NameMap(), where)
	return u
}

func (u *updateBatch[T]) Condition(cond Cond) *updateBatch[T] {
	u.condition = cond
	return u
}

func (u *updateBatch[T]) Do() (int64, error) {
	return u.dao.Exec().Ctx(u.ctx).Must(u.must).LogLevel(u.logLevel).Desc(u.desc).Entities(u.entities...).BuildSql(func(b *gdao.DaoSqlBuilder[T]) {
		var setColumnNum, setNullColumnNum int
		var allIgnore []string
		allIgnore = append(allIgnore, u.setNull...)
		allIgnore = append(allIgnore, u.ignore...)
		allIgnore = append(allIgnore, u.where)

		b.Write("UPDATE ").Write(u.dao.table).Write(" SET ")
		columns := b.Columns(!u.all, allIgnore...)
		b.EachColumn(b.Entity(), b.SepFix("", ", ", "", true), func(_ int, column string, value any) {
			setColumnNum++
			b.Write(column).Write(" = CASE ").Write(u.where)
			b.EachEntity(nil, func(_ int, entity *T) {
				b.Write(" WHEN ").Write("?", b.ColumnValue(entity, u.where)).Write(" THEN ")
				if value != nil {
					b.Write("?").SetArgs(b.ColumnValue(entity, column))
				} else {
					b.Write("NULL")
				}
			})
			b.Write(" END")
		}, columns...)
		if len(u.setNull) > 0 {
			if setColumnNum > 0 {
				b.Write(", ")
			}
			b.Repeat(len(u.setNull), b.Sep(", "), nil, func(_, i int) {
				setNullColumnNum++
				b.Write(u.setNull[i]).Write(" = NULL")
			})
		}

		b.Write(" WHERE ")
		cond := And()
		whereColumnValues := make([]any, 0, len(u.entities))
		b.EachEntity(nil, func(_ int, entity *T) {
			whereColumnValues = append(whereColumnValues, b.ColumnValue(entity, u.where))
		})
		cond.In(u.where, InArgs(whereColumnValues...))
		cond.addCond(u.condition)
		cond.write(u.dao.NameMap(), b.BaseSqlBuilder)
	}).Do()
}

type delete[T any] struct {
	// the base dao
	dao *baseDao[T]
	// the context
	ctx context.Context
	// if true, panic when error occurs, otherwise, return error.
	must bool
	// specify the log level
	logLevel gdao.LogLevel
	// describe the SQL in the log
	desc string
	// conditions of the WHERE clause，create by function And, Or and Not.
	condition Cond
}

func (d *delete[T]) Ctx(ctx context.Context) *delete[T] { // coverage-ignore
	d.ctx = ctx
	return d
}

func (d *delete[T]) Must(must bool) *delete[T] { // coverage-ignore
	d.must = must
	return d
}

func (d *delete[T]) LogLevel(logLevel gdao.LogLevel) *delete[T] { // coverage-ignore
	d.logLevel = logLevel
	return d
}

func (d *delete[T]) Desc(desc string) *delete[T] { // coverage-ignore
	d.desc = desc
	return d
}

func (d *delete[T]) Condition(cond Cond) *delete[T] {
	d.condition = cond
	return d
}

func (d *delete[T]) Do() (int64, error) {
	return d.dao.Exec().Ctx(d.ctx).Must(d.must).LogLevel(d.logLevel).Desc(d.desc).BuildSql(func(b *gdao.DaoSqlBuilder[T]) {
		b.Write("DELETE FROM ").Write(d.dao.table)
		if d.condition != nil && d.condition.len() > 0 {
			b.Write(" WHERE ")
			d.condition.write(d.dao.NameMap(), b.BaseSqlBuilder)
		}
	}).Do()
}

type count[T any] struct {
	// the base dao
	dao *baseDao[T]
	// the context
	ctx context.Context
	// if true, panic when error occurs, otherwise, return error.
	must bool
	// specify the log level
	logLevel gdao.LogLevel
	// describe the SQL in the log
	desc string
	// conditions of the WHERE clause，create by function And, Or and Not.
	condition Cond
}

func (c *count[T]) Ctx(ctx context.Context) *count[T] { // coverage-ignore
	c.ctx = ctx
	return c
}

func (c *count[T]) Must(must bool) *count[T] { // coverage-ignore
	c.must = must
	return c
}

func (c *count[T]) LogLevel(logLevel gdao.LogLevel) *count[T] { // coverage-ignore
	c.logLevel = logLevel
	return c
}

func (c *count[T]) Desc(desc string) *count[T] { // coverage-ignore
	c.desc = desc
	return c
}

func (c *count[T]) Condition(cond Cond) *count[T] {
	c.condition = cond
	return c
}

func (c *count[T]) Do() (*gdao.Count, error) {
	return c.dao.CountDao.Count().Ctx(c.ctx).Must(c.must).LogLevel(c.logLevel).Desc(c.desc).BuildSql(func(b *gdao.CountBuilder) {
		b.Write("SELECT COUNT(*) FROM ").Write(c.dao.table)
		if c.condition != nil && c.condition.len() > 0 {
			b.Write(" WHERE ")
			c.condition.write(c.dao.NameMap(), b.BaseSqlBuilder)
		}
	}).Do()
}

type baseDao[T any] struct {
	*gdao.Dao[T]
	*gdao.CountDao
	table string
}

func (d *baseDao[T]) List() *list[T] {
	return &list[T]{dao: d}
}

func (d *baseDao[T]) Get() *get[T] {
	return &get[T]{dao: d}
}

func (d *baseDao[T]) Insert() *insert[T] {
	return &insert[T]{dao: d}
}

func (d *baseDao[T]) InsertBatch() *insertBatch[T] {
	return &insertBatch[T]{dao: d}
}

func (d *baseDao[T]) Update() *update[T] {
	return &update[T]{dao: d}
}

func (d *baseDao[T]) UpdateBatch() *updateBatch[T] {
	return &updateBatch[T]{dao: d}
}

func (d *baseDao[T]) Delete() *delete[T] {
	return &delete[T]{dao: d}
}

func (d *baseDao[T]) Count() *count[T] {
	return &count[T]{dao: d}
}

type baseDaoBuilder[T any] struct {
	db                *sql.DB
	allowInvalidField bool
	columnMapper      *gdao.NameMapper
	table             string
}

func (b *baseDaoBuilder[T]) DB(db *sql.DB) *baseDaoBuilder[T] { // coverage-ignore
	b.db = db
	return b
}

func (b *baseDaoBuilder[T]) AllowInvalidField(allowInvalidField bool) *baseDaoBuilder[T] { // coverage-ignore
	b.allowInvalidField = allowInvalidField
	return b
}

func (b *baseDaoBuilder[T]) ColumnMapper(columnMapper *gdao.NameMapper) *baseDaoBuilder[T] { // coverage-ignore
	b.columnMapper = columnMapper
	return b
}

func (b *baseDaoBuilder[T]) Table(table string) *baseDaoBuilder[T] {
	b.table = table
	return b
}

func (b *baseDaoBuilder[T]) Build() *baseDao[T] {
	if strings.TrimSpace(b.table) == "" {
		panic("table must not be empty")
	}
	dao := gdao.DaoBuilder[T]().DB(b.db).AllowInvalidField(b.allowInvalidField).ColumnMapper(b.columnMapper).Build()
	countDao := gdao.CountDaoBuilder().DB(b.db).Build()
	return &baseDao[T]{Dao: dao, CountDao: countDao, table: b.table}
}

func BaseDaoBuilder[T any]() *baseDaoBuilder[T] {
	return &baseDaoBuilder[T]{}
}

//=============================================================
//======================== Condition  =========================
//=============================================================

type Cond interface {
	len() int
	setNot()
	setParenthesized()
	write(nameMap map[string]string, b *gdao.BaseSqlBuilder)
}

type baseCond struct {
	not           bool
	parenthesized bool
}

func (bc *baseCond) len() int {
	return 1
}

func (bc *baseCond) setNot() {
	bc.not = true
}

func (bc *baseCond) setParenthesized() {
	bc.parenthesized = true
}

func (bc *baseCond) doWrite(b *gdao.BaseSqlBuilder, write func()) {
	if bc.not {
		b.Write("NOT ")
	}
	if bc.parenthesized {
		b.Write("(")
	}
	write()
	if bc.parenthesized {
		b.Write(")")
	}
}

type notConds struct {
}

func (c notConds) And() *conds {
	return &conds{baseCond: baseCond{not: true}, or: false}
}

func (c notConds) Or() *conds {
	return &conds{baseCond: baseCond{not: true}, or: true}
}

type conds struct {
	baseCond
	nextNot bool
	or      bool
	cs      []Cond
}

func (cs *conds) len() int {
	if cs == nil {
		return 0
	}
	return len(cs.cs)
}

func (cs *conds) write(nameMap map[string]string, b *gdao.BaseSqlBuilder) {
	cs.doWrite(b, func() {
		for i, cond := range cs.cs {
			if i != 0 {
				if cs.or {
					b.Write(" OR ")
				} else {
					b.Write(" AND ")
				}
			}
			cond.write(nameMap, b)
		}
	})
}

func (cs *conds) addCond(c Cond) *conds {
	if c != nil && c.len() > 0 {
		if cs.nextNot {
			c.setNot()
			cs.nextNot = false
		}
		if c.len() > 1 {
			c.setParenthesized()
		}
		cs.cs = append(cs.cs, c)
	}
	return cs
}

func (cs *conds) ToStrArgs(nameMap map[string]string) (string, []any) {
	b := newTempSqlBuilder()
	cs.write(nameMap, b.BaseSqlBuilder)
	return b.Sql(), b.Args()
}

func (cs *conds) Not() *conds {
	cs.nextNot = true
	return cs
}

func (cs *conds) Group(other *conds) *conds {
	return cs.addCond(other)
}

func (cs *conds) Plain(sql string, args ...any) *conds {
	return cs.addCond(&condPlain{sql: sql, args: args})
}

func (cs *conds) Eq(column string, arg any, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && arg == nil {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBinOp{column: column, op: "=", arg: arg})
}

func (cs *conds) Ne(column string, arg any, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && arg == nil {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBinOp{column: column, op: "<>", arg: arg})
}

func (cs *conds) Gt(column string, arg any, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && arg == nil {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBinOp{column: column, op: ">", arg: arg})
}

func (cs *conds) Lt(column string, arg any, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && arg == nil {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBinOp{column: column, op: "<", arg: arg})
}

func (cs *conds) Ge(column string, arg any, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && arg == nil {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBinOp{column: column, op: ">=", arg: arg})
}

func (cs *conds) Le(column string, arg any, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && arg == nil {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBinOp{column: column, op: "<=", arg: arg})
}

func (cs *conds) Like(column string, arg string, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && arg == "" {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBinOp{column: column, op: "LIKE", arg: "%" + arg + "%"})
}

func (cs *conds) LikeLeft(column string, arg string, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && arg == "" {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBinOp{column: column, op: "LIKE", arg: arg + "%"})
}

func (cs *conds) LikeRight(column string, arg string, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && arg == "" {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBinOp{column: column, op: "LIKE", arg: "%" + arg})
}

func (cs *conds) In(column string, args inArgs, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && len(args) == 0 {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condIn{column: column, args: args})
}

func (cs *conds) Between(column string, min, max any, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && (min == nil || max == nil) {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBetween{column: column, min: min, max: max})
}

func (cs *conds) IsNull(column string) *conds {
	return cs.addCond(&condIsNull{column: column})
}

func (cs *conds) IsNotNull(column string) *conds {
	return cs.addCond(&condIsNull{column: column, notNull: true})
}

func (cs *conds) getOpt(opts ...CondOpt) condOpt {
	co := condOpt{}
	for _, opt := range opts {
		opt(&co)
	}
	return co
}

type condPlain struct {
	baseCond
	sql  string
	args []any
}

func (c *condPlain) write(_ map[string]string, b *gdao.BaseSqlBuilder) {
	c.doWrite(b, func() {
		b.Write(c.sql, c.args...)
	})
}

type condBinOp struct {
	baseCond
	column string
	op     string
	arg    any
}

func (c *condBinOp) write(nameMap map[string]string, b *gdao.BaseSqlBuilder) {
	c.doWrite(b, func() {
		b.Write(mapColumn(nameMap, c.column))
		b.Write(" ")
		b.Write(c.op)
		b.Write(" ")
		b.Write("?", c.arg)
	})
}

type condIn struct {
	baseCond
	column string
	args   []any
}

func (c *condIn) write(nameMap map[string]string, b *gdao.BaseSqlBuilder) {
	c.doWrite(b, func() {
		b.Write(mapColumn(nameMap, c.column))
		b.Write(" IN(")
		for i := 0; i < len(c.args); i++ {
			if i != 0 {
				b.Write(", ")
			}
			b.Write("?")
		}
		b.Write(")", c.args...)
	})
}

type condBetween struct {
	baseCond
	column   string
	min, max any
}

func (c *condBetween) write(nameMap map[string]string, b *gdao.BaseSqlBuilder) {
	c.doWrite(b, func() {
		b.Write(mapColumn(nameMap, c.column))
		b.Write(" BETWEEN ? AND ?", c.min, c.max)
	})
}

type condIsNull struct {
	baseCond
	notNull bool
	column  string
}

func (c *condIsNull) write(nameMap map[string]string, b *gdao.BaseSqlBuilder) {
	c.doWrite(b, func() {
		b.Write(mapColumn(nameMap, c.column))
		b.Write(" IS")
		if c.notNull {
			b.Write(" NOT")
		}
		b.Write(" NULL")
	})
}

type inArgs []any

func InArgs[T any](source ...T) inArgs {
	var target inArgs
	for _, s := range source {
		target = append(target, s)
	}
	return target
}

type TempSqlBuilder struct {
	*gdao.BaseSqlBuilder
}

func newTempSqlBuilder() *TempSqlBuilder {
	t := &TempSqlBuilder{}
	t.BaseSqlBuilder = gdao.NewBaseSqlBuilder()
	return t
}

//=============================================================
//===================== Condition Options =====================
//=============================================================

type condOpt struct {
	ifPresent   bool
	ifPredicate func() bool
}

type CondOpt func(*condOpt)

func WithIfPresent() CondOpt {
	return func(opt *condOpt) {
		opt.ifPresent = true
	}
}

func WithIfPredicate(predicate func() bool) CondOpt {
	return func(opt *condOpt) {
		opt.ifPredicate = predicate
	}
}

//=============================================================
//======================= SQL Modifier ========================
//=============================================================

type orderBy struct {
	items []orderByItem
}

func (o *orderBy) Asc(column string) *orderBy {
	o.items = append(o.items, orderByItem{column: column, seq: asc})
	return o
}

func (o *orderBy) Desc(column string) *orderBy {
	o.items = append(o.items, orderByItem{column: column, seq: desc})
	return o
}

func (o *orderBy) write(nameMap map[string]string, b *gdao.BaseSqlBuilder) {
	b.Repeat(len(o.items), b.SepFix(" ORDER BY ", ", ", "", false), nil, func(_, i int) {
		item := o.items[i]
		b.Write(item.column).Write(" ")
		b.Write(string(item.seq))
	})
}

type orderBySeq string

const (
	asc  orderBySeq = "ASC"
	desc            = "DESC"
)

type orderByItem struct {
	column string
	seq    orderBySeq
}

type page struct {
	offset, pageSize int
}

func OrderBy() *orderBy {
	return &orderBy{}
}

func Page(offset, pageSize int) *page {
	return &page{offset: offset, pageSize: pageSize}
}

func And() *conds {
	return &conds{or: false}
}

func Or() *conds {
	return &conds{or: true}
}

func Not() notConds {
	return notConds{}
}

//=============================================================
//========================== Others ===========================
//=============================================================

func mapColumns(nameMap map[string]string, columns []string) []string {
	var target []string
	for _, column := range columns {
		if c, ok := nameMap[column]; ok {
			column = c
		}
		target = append(target, column)
	}
	return target
}

func mapColumn(nameMap map[string]string, column string) string {
	if c, ok := nameMap[column]; ok {
		column = c
	}
	return column
}
