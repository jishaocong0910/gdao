package gen

import (
	"bytes"
	"database/sql"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/jishaocong0910/gdao"
	"golang.org/x/tools/imports"
)

type i_Generator interface {
	m_9A42E0FDDA2E() *m_Generator
	getEntityComment(table string) string
	getEntityFields(table string) []*field
	Gen() []string
}

type m_Generator struct {
	i  i_Generator
	c  Config
	db *sql.DB
}

func (this *m_Generator) m_9A42E0FDDA2E() *m_Generator { // coverage-ignore
	return this
}

func (this *m_Generator) Gen() []string {
	var entities []entity
	for table, fieldTypes := range this.c.Tables {
		e := entity{
			FileName:   this.c.FileNameMapper.AddSuffix(".go").Convert(table),
			Package:    this.getPackageName(),
			EntityName: this.c.EntityNameMapper.Convert(table),
			Comment:    this.i.getEntityComment(table),
			Fields:     this.i.getEntityFields(table),
		}
		for column, fieldType := range fieldTypes {
			for _, f := range e.Fields {
				if f.Column == column {
					f.FieldType = fieldType
					if strings.HasPrefix(f.FieldType, "[]") {
						if !gdao.SupportedFieldTypes.ContainsName(strings.TrimLeft(f.FieldType, "[]")) {
							f.Valid = false
						}
					} else {
						if !strings.HasPrefix(f.FieldType, "*") {
							f.FieldType = "*" + f.FieldType
						}
						if !gdao.SupportedFieldTypes.ContainsName(f.FieldType[1:]) {
							f.Valid = false
						}
					}
				}
			}
		}
		entities = append(entities, e)
	}
	var paths []string
	this.createOutPath()
	for _, e := range entities {
		paths = append(paths, this.createEntity(e))
	}
	return paths
}

func (this *m_Generator) createOutPath() {
	path := this.c.OutPath
	wd := mustReturn(os.Getwd())
	filepath.Join(wd, path)
	mustNoError(os.MkdirAll(path, os.ModePerm))
}

func (this *m_Generator) getPackageName() string {
	if this.c.Package != "" {
		return this.c.Package
	}
	paths := filepath.SplitList(this.c.OutPath)
	return paths[len(paths)-1]
}

func (this *m_Generator) createEntity(e entity) string {
	var buf bytes.Buffer
	t := mustReturn(template.New("").Parse(entityTemplate))
	mustNoError(t.Execute(&buf, e))
	content := mustReturn(imports.Process("", buf.Bytes(), nil))
	path := filepath.Join(this.c.OutPath, e.FileName)
	os.WriteFile(path, content, 0644)
	return path
}

func extendGenerator(i i_Generator, c Config) *m_Generator {
	if c.FileNameMapper == nil {
		c.FileNameMapper = gdao.NewNameMapper().LowerSnakeCase()
	}
	if c.EntityNameMapper == nil {
		c.EntityNameMapper = gdao.NewNameMapper().UpperCamelCase()
	}
	if c.FieldNameMapper == nil {
		c.FieldNameMapper = gdao.NewNameMapper().UpperCamelCase()
	}
	g := &m_Generator{i: i, c: c}
	db, err := sql.Open(c.DbType.DriveName, c.Dsn)
	if err != nil { // coverage-ignore
		panic(fmt.Sprintf("connect db fail, dsn: %s, error: %v", c.Dsn, err))
	}
	g.db = db
	return g
}

const entityTemplate = `// Code generated by https://github.com/alertego/gdao/gen. YOU CAN EDIT FOR MORE.

package {{.Package}}
{{if ne .Comment ""}}
// {{.EntityName}} {{.Comment}}
{{- end}}
type {{.EntityName}} struct {
{{- range $f := .Fields}}
	// {{$f.FieldName}}{{if ne $f.Comment ""}} {{$f.Comment}}{{end}}
	{{- if not $f.Valid}}
	// gdao cannot solve this type!
	{{- end}}
	{{$f.FieldName}} {{$f.FieldType}} ` +
	"`gdao:\"column={{$f.Column}}" +
	"{{if $f.IsAutoIncrement}};auto{{end}}" +
	"\"`" + `
{{- end}}
}`

type entity struct {
	FileName   string
	Package    string
	EntityName string
	Comment    string
	Fields     []*field
}

type field struct {
	Column          string
	FieldName       string
	FieldType       string
	IsAutoSequence  bool
	IsAutoIncrement bool
	Comment         string
	Valid           bool
}

type Config struct {
	// require
	DbType DbType
	// require
	Dsn string
	// require
	OutPath string
	// option
	Package string
	// require
	Tables Tables
	// option
	FileNameMapper *gdao.NameMapper
	// option
	EntityNameMapper *gdao.NameMapper
	// option
	FieldNameMapper *gdao.NameMapper
}

type Tables map[string]FieldTypes

type FieldTypes map[string]string

func Generator(c Config) i_Generator {
	switch c.DbType.ID() {
	case DbTypes.MYSQL.ID():
		return newMySqlGenerator(c)
	case DbTypes.ORACLE.ID():
		return newOracleGenerator(c)
	case DbTypes.POSTGRES.ID():
		return newPostgresGenerator(c)
	//case DbTypes.SQLSERVER.Id:
	//	return newSqlServerGenerator(c)
	//case DbTypes.SQLITE.Id:
	//	return newSqliteGenerator(c)
	default:
		panic("not support this db type yet")
	}
}

func mustNoError(err error) {
	if err != nil { // coverage-ignore
		panic(err)
	}
}

func mustReturn[T any](t T, err error) T {
	if err != nil { // coverage-ignore
		panic(err)
	}
	return t
}
