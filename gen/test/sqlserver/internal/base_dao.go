// Code generated by https://github.com/jishaocong0910/gdao. FOR SQL Server. DO NOT EDIT.

package testdata

import (
	"context"
	"strconv"
	"strings"

	"github.com/jishaocong0910/gdao"
)

type ListReq struct {
	// the context
	Ctx context.Context
	// if true, panic when error occurs, otherwise, return error.
	Must bool
	// specify the SQL log level
	SqlLogLevel gdao.SqlLogLevel
	// describe the SQL in the log
	Desc string
	// specify the columns which in the select column list, default is all columns.
	SelectColumns []string
	// conditions of the WHERE clause，create by function And, Or and Not.
	Condition Cond
	// ORDER BY clause，create by function Sort.
	Sort *OrderBy
	// paging query，create by function Page.
	Page *Pagination
	// FOR UPDATE clause
	ForUpdate bool
}

type GetReq struct {
	// the context
	Ctx context.Context
	// if true, panic when error occurs, otherwise, return error.
	Must bool
	// specify the SQL log level
	SqlLogLevel gdao.SqlLogLevel
	// describe the SQL in the log
	Desc string
	// specify the columns which in the select column list, default is all columns.
	SelectColumns []string
	// conditions of the WHERE clause，create by function And, Or and Not.
	Condition Cond
	// ORDER BY clause，create by function Sort.
	Sort *OrderBy
	// FOR UPDATE clause
	ForUpdate bool
}

type InsertReq[T any] struct {
	// the context
	Ctx context.Context
	// if true, panic when error occurs, otherwise, return error.
	Must bool
	// specify the SQL log level
	SqlLogLevel gdao.SqlLogLevel
	// describe the SQL in the log
	Desc string
	// the non-nil fields will be saved, and the auto generated keys will be set in it.
	Entity *T
	// if true, all fields will be saved, otherwise, save non-nil fields.
	InsertAll bool
	// specify the columns which set a null value
	SetNullColumns []string
	// specify the columns which be not set
	IgnoredColumns []string
}

type InsertBatchReq[T any] struct {
	// the context
	Ctx context.Context
	// if true, panic when error occurs, otherwise, return error.
	Must bool
	// specify the SQL log level
	SqlLogLevel gdao.SqlLogLevel
	// describe the SQL in the log
	Desc string
	// each element corresponds to a record to be saved, and the auto generated keys will be set in them.
	Entities []*T
	// if true, all fields will be saved, otherwise, save non-nil fields.
	InsertAll bool
	// specify the columns which set a null value
	SetNullColumns []string
	// specify the columns which be not set
	IgnoredColumns []string
}

type UpdateReq[T any] struct {
	// the context
	Ctx context.Context
	// if true, panic when error occurs, otherwise, return error.
	Must bool
	// specify the SQL log level
	SqlLogLevel gdao.SqlLogLevel
	// describe the SQL in the log
	Desc string
	// uses to update values or as the WHERE clause conditions.
	Entity *T
	// if true, all fields will be updated, otherwise, update non-nil fields.
	UpdateAll bool
	// specify the columns which set a null value
	SetNullColumns []string
	// specify the columns which be not set
	IgnoredColumns []string
	// specify the non-nil fields in the entity used as conditions.
	WhereColumns []string
	// conditions of the WHERE clause，create by function And, Or and Not..
	Condition Cond
}

type UpdateBatchReq[T any] struct {
	// the context
	Ctx context.Context
	// if true, panic when error occurs, otherwise, return error.
	Must bool
	// specify the SQL log level
	SqlLogLevel gdao.SqlLogLevel
	// describe the SQL in the log
	Desc string
	// each element corresponds to a record to be updated.
	Entities []*T
	// if true, all fields will be updated, otherwise, update non-nil fields.
	UpdateAll bool
	// specify the columns which set a null value
	SetNullColumns []string
	// specify the columns which be not set
	IgnoredColumns []string
	// specify the column which used as a condition.
	WhereColumn string
	// conditions of the WHERE clause，create by function And, Or and Not..
	Condition Cond
}

type DeleteReq struct {
	// the context
	Ctx context.Context
	// if true, panic when error occurs, otherwise, return error.
	Must bool
	// specify the SQL log level
	SqlLogLevel gdao.SqlLogLevel
	// describe the SQL in the log
	Desc string
	// conditions of the WHERE clause，create by function And, Or and Not.
	Condition Cond
}

type CountReq struct {
	// the context
	Ctx context.Context
	// if true, panic when error occurs, otherwise, return error.
	Must bool
	// specify the SQL log level
	SqlLogLevel gdao.SqlLogLevel
	// describe the SQL in the log
	Desc string
	// conditions of the WHERE clause，create by function And, Or and Not.
	Condition Cond
}

type baseDao[T any] struct {
	*gdao.Dao[T]
	*gdao.CountDao
	table string
}

// List queries records of the conditions.
func (d baseDao[T]) List(req ListReq) ([]*T, error) {
	_, list, err := d.Query(gdao.QueryReq[T]{Ctx: req.Ctx, Must: req.Must, SqlLogLevel: req.SqlLogLevel, Desc: req.Desc, BuildSql: func(b *gdao.DaoSqlBuilder[T]) {
		var pagingType int
		if req.Page != nil {
			if req.Page.offset > 0 {
				pagingType = 1
			} else {
				pagingType = 2
			}
		}
		b.Write("SELECT ")
		if pagingType == 2 {
			b.Write(" TOP ")
			b.Write(strconv.FormatInt(int64(req.Page.pageSize), 10))
			b.Write(" ")
		}
		b.WriteColumns(req.SelectColumns...).Write(" FROM ").Write(d.table)
		if req.Condition != nil && req.Condition.len() > 0 {
			b.Write(" WHERE ")
			req.Condition.write(b.BaseSqlBuilder__)
		}
		if req.Sort != nil {
			b.Repeat(len(req.Sort.items), b.SepFix(" ORDER BY ", ", ", "", false), nil, func(_, i int) {
				item := req.Sort.items[i]
				b.Write(item.column).Write(" ")
				b.Write(string(item.seq))
			})
		}
		if pagingType == 1 {
			b.Write(" OFFSET ")
			b.Write(strconv.FormatInt(int64(req.Page.offset), 10))
			b.Write(" FETCH NEXT ")
			b.Write(strconv.FormatInt(int64(req.Page.pageSize), 10))
			b.Write(" ROWS ONLY")
		}
		if req.ForUpdate {
			b.Write(" FOR UPDATE")
		}
	}})
	return list, err
}

// Get queries a record of the conditions.
func (d baseDao[T]) Get(req GetReq) (entity *T, err error) {
	list, err := d.List(ListReq{
		Ctx:           req.Ctx,
		Must:          req.Must,
		SqlLogLevel:   req.SqlLogLevel,
		Desc:          req.Desc,
		SelectColumns: req.SelectColumns,
		Condition:     req.Condition,
		Sort:          req.Sort,
		Page:          Page(0, 1),
		ForUpdate:     req.ForUpdate,
	})
	if len(list) > 0 {
		entity = list[0]
	}
	return
}

// Insert saves a record and return the auto generated keys.
func (d baseDao[T]) Insert(req InsertReq[T]) error {
	return d.InsertBatch(InsertBatchReq[T]{
		Ctx:            req.Ctx,
		Must:           req.Must,
		SqlLogLevel:    req.SqlLogLevel,
		Desc:           req.Desc,
		Entities:       []*T{req.Entity},
		InsertAll:      req.InsertAll,
		SetNullColumns: req.SetNullColumns,
		IgnoredColumns: req.IgnoredColumns,
	})
}

// InsertBatch saves records and return the auto generated keys.
func (d baseDao[T]) InsertBatch(req InsertBatchReq[T]) error {
	_, _, err := d.Query(gdao.QueryReq[T]{Ctx: req.Ctx, Must: req.Must, SqlLogLevel: req.SqlLogLevel, Desc: req.Desc, RowAs: gdao.RowAs_.LAST_ID, Entities: req.Entities,
		BuildSql: func(b *gdao.DaoSqlBuilder[T]) {
			var setColumnNum, setNullColumnNum int
			var allIgnoredColumns []string
			allIgnoredColumns = append(allIgnoredColumns, req.SetNullColumns...)
			allIgnoredColumns = append(allIgnoredColumns, req.IgnoredColumns...)
			allIgnoredColumns = append(allIgnoredColumns, b.AutoColumns()...)

			b.Write("INSERT INTO ").Write(d.table)

			columns := b.Columns(!req.InsertAll, allIgnoredColumns...)
			b.Repeat(len(columns), b.SepFix("(", ", ", "", true), nil, func(_, i int) {
				setColumnNum++
				b.Write(columns[i])
			})
			if len(req.SetNullColumns) > 0 {
				if setColumnNum > 0 {
					b.Write(", ")
				}
				b.Repeat(len(req.SetNullColumns), b.Sep(", "), nil, func(_, i int) {
					setNullColumnNum++
					b.Write(req.SetNullColumns[i])
				})
			}
			b.Write(")")

			b.Write(" VALUES")
			b.EachEntity(b.Sep(", "), func(_ int, entity *T) {
				b.EachColumn(entity, b.SepFix("(", ", ", "", true), func(_ int, column string, value any) {
					if value != nil {
						b.Write(b.Pp(":"), value)
					} else {
						b.Write("NULL")
					}
				}, columns...)
				if len(req.SetNullColumns) > 0 {
					if setColumnNum > 0 {
						b.Write(", ")
					}
					b.Repeat(len(req.SetNullColumns), b.Sep(", "), nil, func(_, i int) {
						b.Write("NULL")
					})
				}
				b.Write(")")
			})

			if len(b.AutoColumns()) == 1 {
				b.Write("; SELECT ID = convert(bigint, SCOPE_IDENTITY())")
			}
		}})
	return err
}

// Update modifies a record.
func (d baseDao[T]) Update(req UpdateReq[T]) (int64, error) {
	return d.Exec(gdao.ExecReq[T]{Ctx: req.Ctx, Must: req.Must, SqlLogLevel: req.SqlLogLevel, Desc: req.Desc, Entities: []*T{req.Entity},
		BuildSql: func(b *gdao.DaoSqlBuilder[T]) {
			var setColumnNum, setNullColumnNum int
			var allIgnoredColumns []string
			allIgnoredColumns = append(allIgnoredColumns, req.SetNullColumns...)
			allIgnoredColumns = append(allIgnoredColumns, req.IgnoredColumns...)
			allIgnoredColumns = append(allIgnoredColumns, req.WhereColumns...)

			b.Write("UPDATE ").Write(d.table).Write(" SET ")

			columns := b.Columns(!req.UpdateAll, allIgnoredColumns...)
			b.EachColumn(b.Entity(), b.SepFix("", ", ", "", true), func(_ int, column string, value any) {
				setColumnNum++
				b.Write(column).Write(" = ")
				if value != nil {
					b.Write(b.Pp(":")).SetArgs(value)
				} else {
					b.Write("NULL")
				}
			}, columns...)
			if len(req.SetNullColumns) > 0 {
				if setColumnNum > 0 {
					b.Write(", ")
				}
				b.Repeat(len(req.SetNullColumns), b.Sep(", "), nil, func(_, i int) {
					setNullColumnNum++
					b.Write(req.SetNullColumns[i]).Write(" = NULL")
				})
			}

			cond := And()
			if len(req.WhereColumns) > 0 {
				b.EachColumn(b.Entity(), nil, func(_ int, column string, value any) {
					if value == nil {
						cond.IsNull(column)
					} else {
						cond.Eq(column, value)
					}
				}, req.WhereColumns...)
			}
			cond.addCond(req.Condition)
			if cond.len() > 0 {
				b.Write(" WHERE ")
				cond.write(b.BaseSqlBuilder__)
			}
		}})
}

// UpdateBatch modifies multiple records by a SQL.
func (d baseDao[T]) UpdateBatch(req UpdateBatchReq[T]) (int64, error) {
	return d.Exec(gdao.ExecReq[T]{Ctx: req.Ctx, Must: req.Must, SqlLogLevel: req.SqlLogLevel, Desc: req.Desc, Entities: req.Entities, BuildSql: func(b *gdao.DaoSqlBuilder[T]) {
		var setColumnNum, setNullColumnNum int
		var allIgnoredColumns []string
		allIgnoredColumns = append(allIgnoredColumns, req.SetNullColumns...)
		allIgnoredColumns = append(allIgnoredColumns, req.IgnoredColumns...)
		allIgnoredColumns = append(allIgnoredColumns, req.WhereColumn)

		b.Write("UPDATE ").Write(d.table).Write(" SET ")

		columns := b.Columns(!req.UpdateAll, allIgnoredColumns...)
		b.EachColumn(b.Entity(), b.SepFix("", ", ", "", true), func(_ int, column string, value any) {
			setColumnNum++
			b.Write(column).Write(" = CASE ").Write(req.WhereColumn)
			b.EachEntity(nil, func(_ int, entity *T) {
				b.Write(" WHEN ").Write(b.Pp(":"), b.ColumnValue(entity, req.WhereColumn)).Write(" THEN ")
				if value != nil {
					b.Write(b.Pp(":")).SetArgs(b.ColumnValue(entity, column))
				} else {
					b.Write("NULL")
				}
			})
			b.Write(" END")
		}, columns...)
		if len(req.SetNullColumns) > 0 {
			if setColumnNum > 0 {
				b.Write(", ")
			}
			b.Repeat(len(req.SetNullColumns), b.Sep(", "), nil, func(_, i int) {
				setNullColumnNum++
				b.Write(req.SetNullColumns[i]).Write(" = NULL")
			})
		}

		b.Write(" WHERE ")
		cond := And()
		whereColumnValues := make([]any, 0, len(req.Entities))
		b.EachEntity(nil, func(_ int, entity *T) {
			whereColumnValues = append(whereColumnValues, b.ColumnValue(entity, req.WhereColumn))
		})
		cond.In(req.WhereColumn, InArgs(whereColumnValues...))
		cond.addCond(req.Condition)
		cond.write(b.BaseSqlBuilder__)
	}})
}

// Delete removes records.
func (d baseDao[T]) Delete(req DeleteReq) (int64, error) {
	return d.Exec(gdao.ExecReq[T]{Ctx: req.Ctx, Must: req.Must, SqlLogLevel: req.SqlLogLevel, Desc: req.Desc, BuildSql: func(b *gdao.DaoSqlBuilder[T]) {
		b.Write("DELETE FROM ").Write(d.table)
		if req.Condition != nil && req.Condition.len() > 0 {
			b.Write(" WHERE ")
			req.Condition.write(b.BaseSqlBuilder__)
		}
	}})
}

// Count return a count of the number of records returned
func (d baseDao[T]) Count(req CountReq) (*gdao.Count, error) {
	count, err := d.CountDao.Count(gdao.CountReq{Ctx: req.Ctx, Must: req.Must, SqlLogLevel: req.SqlLogLevel, Desc: req.Desc, BuildSql: func(b *gdao.CountBuilder) {
		b.Write("SELECT COUNT(*) FROM ").Write(d.table)
		if req.Condition != nil && req.Condition.len() > 0 {
			b.Write(" WHERE ")
			req.Condition.write(b.BaseSqlBuilder__)
		}
	}})
	return count, err
}

func newBaseDao[T any](req gdao.NewDaoReq, table string) *baseDao[T] {
	dao := gdao.NewDao[T](req)
	countDao := gdao.NewCountDao(gdao.NewCountDaoReq{DB: req.DB})
	table = strings.TrimSpace(table)
	if table == "" {
		panic(`parameter "table" must not be blank`)
	}
	return &baseDao[T]{Dao: dao, CountDao: countDao, table: table}
}

//=============================================================
//======================== Condition  =========================
//=============================================================

type Cond interface {
	len() int
	setNot()
	setParenthesized()
	write(b *gdao.BaseSqlBuilder__)
}

type baseCond struct {
	not           bool
	parenthesized bool
}

func (bc *baseCond) len() int {
	return 1
}

func (bc *baseCond) setNot() {
	bc.not = true
}

func (bc *baseCond) setParenthesized() {
	bc.parenthesized = true
}

func (bc *baseCond) doWrite(b *gdao.BaseSqlBuilder__, write func()) {
	if bc.not {
		b.Write("NOT ")
	}
	if bc.parenthesized {
		b.Write("(")
	}
	write()
	if bc.parenthesized {
		b.Write(")")
	}
}

type notConds struct {
}

func (c notConds) And() *conds {
	return &conds{baseCond: baseCond{not: true}, or: false}
}

func (c notConds) Or() *conds {
	return &conds{baseCond: baseCond{not: true}, or: true}
}

type conds struct {
	baseCond
	nextNot bool
	or      bool
	cs      []Cond
}

func (cs *conds) len() int {
	if cs == nil {
		return 0
	}
	return len(cs.cs)
}

func (cs *conds) write(b *gdao.BaseSqlBuilder__) {
	cs.doWrite(b, func() {
		for i, cond := range cs.cs {
			if i != 0 {
				if cs.or {
					b.Write(" OR ")
				} else {
					b.Write(" AND ")
				}
			}
			cond.write(b)
		}
	})
}

func (cs *conds) addCond(c Cond) *conds {
	if c != nil && c.len() > 0 {
		if cs.nextNot {
			c.setNot()
			cs.nextNot = false
		}
		if c.len() > 1 {
			c.setParenthesized()
		}
		cs.cs = append(cs.cs, c)
	}
	return cs
}

func (cs *conds) ToStrArgs() (string, []any) {
	b := newTempSqlBuilder()
	cs.write(b.BaseSqlBuilder__)
	return b.Sql(), b.Args()
}

func (cs *conds) Not() *conds {
	cs.nextNot = true
	return cs
}

func (cs *conds) Group(other *conds) *conds {
	return cs.addCond(other)
}

func (cs *conds) Plain(sql string, args ...any) *conds {
	return cs.addCond(&condPlain{sql: sql, args: args})
}

func (cs *conds) Eq(column string, arg any, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && arg == nil {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBinOp{column: column, op: "=", arg: arg})
}

func (cs *conds) Ne(column string, arg any, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && arg == nil {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBinOp{column: column, op: "<>", arg: arg})
}

func (cs *conds) Gt(column string, arg any, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && arg == nil {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBinOp{column: column, op: ">", arg: arg})
}

func (cs *conds) Lt(column string, arg any, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && arg == nil {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBinOp{column: column, op: "<", arg: arg})
}

func (cs *conds) Ge(column string, arg any, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && arg == nil {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBinOp{column: column, op: ">=", arg: arg})
}

func (cs *conds) Le(column string, arg any, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && arg == nil {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBinOp{column: column, op: "<=", arg: arg})
}

func (cs *conds) Like(column string, arg string, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && arg == "" {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBinOp{column: column, op: "LIKE", arg: "%" + arg + "%"})
}

func (cs *conds) LikeLeft(column string, arg string, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && arg == "" {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBinOp{column: column, op: "LIKE", arg: arg + "%"})
}

func (cs *conds) LikeRight(column string, arg string, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && arg == "" {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBinOp{column: column, op: "LIKE", arg: "%" + arg})
}

func (cs *conds) In(column string, args inArgs, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && len(args) == 0 {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condIn{column: column, args: args})
}

func (cs *conds) Between(column string, min, max any, opts ...CondOpt) *conds {
	opt := cs.getOpt(opts...)
	if opt.ifPresent && (min == nil || max == nil) {
		return cs
	}
	if opt.ifPredicate != nil {
		if !opt.ifPredicate() {
			return cs
		}
	}
	return cs.addCond(&condBetween{column: column, min: min, max: max})
}

func (cs *conds) IsNull(column string) *conds {
	return cs.addCond(&condIsNull{column: column})
}

func (cs *conds) IsNotNull(column string) *conds {
	return cs.addCond(&condIsNull{column: column, notNull: true})
}

func (cs *conds) getOpt(opts ...CondOpt) condOpt {
	co := condOpt{}
	for _, opt := range opts {
		opt(&co)
	}
	return co
}

type condPlain struct {
	baseCond
	sql  string
	args []any
}

func (c *condPlain) write(b *gdao.BaseSqlBuilder__) {
	c.doWrite(b, func() {
		b.Write(c.sql, c.args...)
	})
}

type condBinOp struct {
	baseCond
	column string
	op     string
	arg    any
}

func (c *condBinOp) write(b *gdao.BaseSqlBuilder__) {
	c.doWrite(b, func() {
		b.Write(c.column)
		b.Write(" ")
		b.Write(c.op)
		b.Write(" ")
		b.Write(b.Pp(":"), c.arg)
	})
}

type condIn struct {
	baseCond
	column string
	args   []any
}

func (c *condIn) write(b *gdao.BaseSqlBuilder__) {
	c.doWrite(b, func() {
		b.Write(c.column)
		b.Write(" IN(")
		for i := 0; i < len(c.args); i++ {
			if i != 0 {
				b.Write(", ")
			}
			b.Write(b.Pp(":"))
		}
		b.Write(")", c.args...)
	})
}

type condBetween struct {
	baseCond
	column   string
	min, max any
}

func (c *condBetween) write(b *gdao.BaseSqlBuilder__) {
	c.doWrite(b, func() {
		b.Write(c.column)
		b.Write(" BETWEEN ")
		b.Write(b.Pp(":"))
		b.Write(" AND ")
		b.Write(b.Pp(":"), c.min, c.max)
	})
}

type condIsNull struct {
	baseCond
	notNull bool
	column  string
}

func (c *condIsNull) write(b *gdao.BaseSqlBuilder__) {
	c.doWrite(b, func() {
		b.Write(c.column)
		b.Write(" IS")
		if c.notNull {
			b.Write(" NOT")
		}
		b.Write(" NULL")
	})
}

type TempSqlBuilder struct {
	*gdao.BaseSqlBuilder__
}

func newTempSqlBuilder() *TempSqlBuilder {
	this := &TempSqlBuilder{}
	this.BaseSqlBuilder__ = gdao.ExtendBaseSqlBuilder(this)
	return this
}

//=============================================================
//===================== Condition Options =====================
//=============================================================

type condOpt struct {
	ifPresent   bool
	ifPredicate func() bool
}

type CondOpt func(*condOpt)

func WithIfPresent() CondOpt {
	return func(opt *condOpt) {
		opt.ifPresent = true
	}
}

func WithIfPredicate(predicate func() bool) CondOpt {
	return func(opt *condOpt) {
		opt.ifPredicate = predicate
	}
}

//=============================================================
//======================= SQL Modifier ========================
//=============================================================

type OrderBy struct {
	items []orderByItem
}

func (o *OrderBy) Asc(column string) *OrderBy {
	o.items = append(o.items, orderByItem{column: column, seq: asc})
	return o
}

func (o *OrderBy) Desc(column string) *OrderBy {
	o.items = append(o.items, orderByItem{column: column, seq: desc})
	return o
}

type orderBySeq string

const (
	asc  orderBySeq = "ASC"
	desc            = "DESC"
)

type orderByItem struct {
	column string
	seq    orderBySeq
}

type Pagination struct {
	offset, pageSize int
}

func Sort() *OrderBy {
	return &OrderBy{}
}

func Page(offset, pageSize int) *Pagination {
	return &Pagination{offset: offset, pageSize: pageSize}
}

func And() *conds {
	return &conds{or: false}
}

func Or() *conds {
	return &conds{or: true}
}

func Not() notConds {
	return notConds{}
}

//=============================================================
//======================= Handy Function ======================
//=============================================================

type inArgs []any

func InArgs[T any](source ...T) inArgs {
	var target inArgs
	for _, s := range source {
		target = append(target, s)
	}
	return target
}

func Entities[T any](entities ...*T) []*T {
	return entities
}

func Columns(columns ...string) []string {
	return columns
}
